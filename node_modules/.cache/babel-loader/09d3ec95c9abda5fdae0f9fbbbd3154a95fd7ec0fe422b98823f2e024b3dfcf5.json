{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\nvar Long = require('long');\nvar BufferMaker = function () {\n  this.plan = [];\n};\nvar types = {\n  \"UInt8\": {\n    bytes: 1\n  },\n  \"Int8\": {\n    bytes: 1\n  },\n  \"Int16BE\": {\n    bytes: 2\n  },\n  \"Int32BE\": {\n    bytes: 4\n  },\n  \"Int16LE\": {\n    bytes: 2\n  },\n  \"Int32LE\": {\n    bytes: 4\n  },\n  \"UInt16BE\": {\n    bytes: 2\n  },\n  \"UInt32BE\": {\n    bytes: 4\n  },\n  \"FloatLE\": {\n    bytes: 4\n  },\n  \"DoubleLE\": {\n    bytes: 8\n  },\n  \"FloatBE\": {\n    bytes: 4\n  },\n  \"DoubleBE\": {\n    bytes: 8\n  },\n  \"UInt16LE\": {\n    bytes: 2\n  },\n  \"UInt32LE\": {\n    bytes: 4\n  },\n  \"Int64BE\": {\n    bytes: 8\n  },\n  \"string\": {}\n};\n\n// create methods for each type\nfunction addTypeMethod(type) {\n  BufferMaker.prototype[type] = function (val) {\n    this.plan.push({\n      type: type,\n      value: val\n    });\n    return this;\n  };\n}\nfor (var type in types) {\n  addTypeMethod(type);\n}\nBufferMaker.prototype.make = function () {\n  var bytecount = 0;\n  var offset = 0;\n  var item;\n  var i,\n    j = 0;\n  for (i = 0; i < this.plan.length; i++) {\n    item = this.plan[i];\n    if (item.type === 'string') {\n      if (Buffer.isBuffer(item.value)) {\n        bytecount += item.value.length;\n      } else {\n        bytecount += Buffer.byteLength(item.value);\n      }\n    } else {\n      bytecount += types[item.type].bytes;\n    }\n  }\n  var buffer = new Buffer(bytecount);\n  for (i = 0; i < this.plan.length; i++) {\n    item = this.plan[i];\n    switch (item.type) {\n      case \"Int64BE\":\n        var longVal = Long.fromString(item.value + \"\");\n        buffer.writeInt32BE(longVal.getHighBits(), offset); //write the high order bits (shifted over)\n        buffer.writeInt32BE(longVal.getLowBits(), offset + 4); //write the low order bits\n        offset += 8;\n        break;\n      case \"string\":\n        if (typeof item.value === 'string') {\n          buffer.write(item.value, offset);\n          offset += Buffer.byteLength(item.value);\n        } else {\n          item.value.copy(buffer, offset, 0);\n          offset += item.value.length;\n        }\n        break;\n      default:\n        buffer['write' + item.type](item.value, offset);\n        offset += types[item.type].bytes;\n    }\n  }\n  return buffer;\n};\nmodule.exports = BufferMaker;","map":{"version":3,"names":["Long","require","BufferMaker","plan","types","bytes","addTypeMethod","type","prototype","val","push","value","make","bytecount","offset","item","i","j","length","Buffer","isBuffer","byteLength","buffer","longVal","fromString","writeInt32BE","getHighBits","getLowBits","write","copy","module","exports"],"sources":["D:/Project/VUEJSSPRING_CRUD_JWT/vue-crud-api-jwt-vuex/node_modules/buffermaker/lib/BufferMaker.js"],"sourcesContent":["var Long = require('long');\n\n\nvar BufferMaker = function(){\n  this.plan = [];\n};\n\nvar types = {\"UInt8\" : { bytes : 1},\n              \"Int8\" : { bytes : 1},\n              \"Int16BE\" : { bytes : 2},\n              \"Int32BE\" : { bytes : 4},\n              \"Int16LE\" : { bytes : 2},\n              \"Int32LE\" : { bytes : 4},\n              \"UInt16BE\" : { bytes : 2},\n              \"UInt32BE\" : { bytes : 4},\n              \"FloatLE\" : { bytes : 4},\n              \"DoubleLE\" : { bytes: 8},\n              \"FloatBE\" : { bytes : 4},\n              \"DoubleBE\" : { bytes : 8},\n              \"UInt16LE\" : { bytes : 2},\n              \"UInt32LE\" : { bytes : 4},\n              \"Int64BE\" : { bytes : 8},\n              \"string\" : {}\n            };\n\n// create methods for each type\nfunction addTypeMethod(type){\n  BufferMaker.prototype[type] = function(val){\n    this.plan.push({ type : type, value : val});\n    return this;\n  };\n}\n\nfor(var type in types){\n  addTypeMethod(type);\n}\n\n\nBufferMaker.prototype.make = function(){\n  var bytecount = 0;\n  var offset = 0;\n  var item;\n  var i, j = 0;\n  for(i = 0; i < this.plan.length; i++){\n    item = this.plan[i];\n    if (item.type === 'string'){\n      if (Buffer.isBuffer(item.value)){\n        bytecount += item.value.length;\n      } else {\n        bytecount += Buffer.byteLength(item.value);\n      }\n    } else {\n      bytecount += types[item.type].bytes;\n    }\n  }\n  var buffer = new Buffer(bytecount);\n  for(i = 0; i < this.plan.length; i++){\n    item = this.plan[i];\n    switch(item.type){\n      case \"Int64BE\":\n        var longVal = Long.fromString(item.value  + \"\");\n        buffer.writeInt32BE(longVal.getHighBits(), offset); //write the high order bits (shifted over)\n        buffer.writeInt32BE(longVal.getLowBits(), offset + 4); //write the low order bits\n        offset += 8;\n        break;\n      case \"string\": \n        if (typeof item.value === 'string'){\n          buffer.write(item.value, offset);\n          offset += Buffer.byteLength(item.value);\n        } else {\n          item.value.copy(buffer, offset, 0);\n          offset += item.value.length;\n        }\n\n        break;\n      default :\n        buffer['write' + item.type](item.value, offset);\n        offset += types[item.type].bytes;\n    }\n  }\n  return buffer;\n\n};\n\nmodule.exports = BufferMaker;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}