{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\nconst Transform = stream.Transform;\nconst _ = require('lodash');\nvar DEFAULTS = {\n  // Auto commit config\n  autoCommit: true,\n  autoCommitIntervalMs: 5000,\n  autoCommitMsgCount: 100,\n  // Whether to act as a transform stream and emit the events we observe.\n  // If we write all data this stream will fill its buffer and then provide\n  // backpressure preventing our continued reading.\n  passthrough: false\n};\nclass CommitStream extends Transform {\n  constructor(client, topics, groupId, options) {\n    options = options || {};\n    let parentOptions = _.defaults({\n      highWaterMark: options.highWaterMark\n    }, {\n      objectMode: true\n    });\n    super(parentOptions);\n    this.options = _.defaults(options || {}, DEFAULTS);\n    this.client = client;\n    this.topicPartionOffsets = this.buildTopicData(_.cloneDeep(topics));\n    this.committing = false;\n    this.groupId = groupId;\n    this.autoCommit = options.autoCommit;\n    this.autoCommitMsgCount = options.autoCommitMsgCount;\n    this.autoCommitIntervalMs = options.autoCommitIntervalMs;\n    this.autoCommitIntervalTimer = null;\n    if (this.autoCommit && this.autoCommitIntervalMs) {\n      this.autoCommitIntervalTimer = setInterval(function () {\n        this.commit();\n      }.bind(this), this.autoCommitIntervalMs);\n    }\n    this.messageCount = 0;\n  }\n\n  /**\n   * Extend Transform::on() to act as a pipe if someone consumes data from us.\n   */\n  on(eventName) {\n    if (eventName === 'data') {\n      this.options.passthrough = true;\n    }\n    super.on.apply(this, arguments);\n  }\n\n  /**\n   * Extend Transform::pipe() to act as a pipe if someone consumes data from us.\n   */\n  pipe() {\n    this.options.passthrough = true;\n    super.pipe.apply(this, arguments);\n  }\n  _transform(data, encoding, done) {\n    let topicUpdate = {};\n    let self = this;\n    topicUpdate[data.topic] = {};\n    topicUpdate[data.topic][data.partition] = data.offset;\n    self.updateOffsets(topicUpdate);\n    self.messageCount++;\n    const doneWrapper = function () {\n      // We need to act as a through stream if we are not\n      // purely a terminal write stream.\n      if (self.options.passthrough) {\n        return done(null, data);\n      }\n      done();\n    };\n    if (self.autoCommit && self.messageCount === self.autoCommitMsgCount) {\n      self.messageCount = 0;\n      return self.commit(doneWrapper);\n    }\n    doneWrapper();\n  }\n  buildTopicData(topicPartions) {\n    return topicPartions.map(function (partion) {\n      if (typeof partion !== 'object') partion = {\n        topic: partion\n      };\n      partion.partition = partion.partition || 0;\n      partion.offset = partion.offset || 0;\n      // Metadata can be arbitrary\n      partion.metadata = 'm';\n      return partion;\n    });\n  }\n\n  /**\n   * @param {Object} topics - An object containing topic offset data keyed by\n   *   topic with keys for partion containing the offset last seen.\n   */\n  updateOffsets(topics, initing) {\n    this.topicPartionOffsets.forEach(function (p) {\n      if (!_.isEmpty(topics[p.topic]) && topics[p.topic][p.partition] !== undefined) {\n        var offset = topics[p.topic][p.partition];\n        if (offset === -1) offset = 0;\n        // Note, we track the offset of the next message we want to see,\n        // not the most recent message we have seen.\n        if (!initing) p.offset = offset + 1;else p.offset = offset;\n      }\n    });\n  }\n\n  /**\n   * Clear the autocommit interval of this commitStream if set.\n   */\n  clearInterval() {\n    clearInterval(this.autoCommitIntervalTimer);\n  }\n  commit(cb) {\n    let self = this;\n    if (!cb) {\n      cb = function noop() {};\n    }\n    if (self.committing) {\n      return cb(null, 'Commit in progress');\n    }\n    let topicPartionOffsets = self.topicPartionOffsets;\n    let commits = topicPartionOffsets.filter(function (partition) {\n      return partition.offset !== 0;\n    });\n    if (commits.length) {\n      self.committing = true;\n      self.client.sendOffsetCommitRequest(self.groupId, commits, function () {\n        self.emit('commitComplete', {\n          group: self.groupId,\n          commits\n        });\n        self.committing = false;\n        cb.apply(this, arguments);\n      });\n    } else {\n      cb(null, 'Nothing to be committed');\n    }\n  }\n}\nmodule.exports = CommitStream;","map":{"version":3,"names":["stream","require","Transform","_","DEFAULTS","autoCommit","autoCommitIntervalMs","autoCommitMsgCount","passthrough","CommitStream","constructor","client","topics","groupId","options","parentOptions","defaults","highWaterMark","objectMode","topicPartionOffsets","buildTopicData","cloneDeep","committing","autoCommitIntervalTimer","setInterval","commit","bind","messageCount","on","eventName","apply","arguments","pipe","_transform","data","encoding","done","topicUpdate","self","topic","partition","offset","updateOffsets","doneWrapper","topicPartions","map","partion","metadata","initing","forEach","p","isEmpty","undefined","clearInterval","cb","noop","commits","filter","length","sendOffsetCommitRequest","emit","group","module","exports"],"sources":["D:/Project/VUEJSSPRING_CRUD_JWT/vue-crud-api-jwt-vuex/node_modules/kafka-node/lib/commitStream.js"],"sourcesContent":["'use strict';\n\nconst stream = require('stream');\nconst Transform = stream.Transform;\n\nconst _ = require('lodash');\n\nvar DEFAULTS = {\n  // Auto commit config\n  autoCommit: true,\n  autoCommitIntervalMs: 5000,\n  autoCommitMsgCount: 100,\n  // Whether to act as a transform stream and emit the events we observe.\n  // If we write all data this stream will fill its buffer and then provide\n  // backpressure preventing our continued reading.\n  passthrough: false\n};\n\nclass CommitStream extends Transform {\n  constructor (client, topics, groupId, options) {\n    options = options || {};\n    let parentOptions = _.defaults({ highWaterMark: options.highWaterMark }, { objectMode: true });\n    super(parentOptions);\n\n    this.options = _.defaults(options || {}, DEFAULTS);\n    this.client = client;\n    this.topicPartionOffsets = this.buildTopicData(_.cloneDeep(topics));\n\n    this.committing = false;\n    this.groupId = groupId;\n\n    this.autoCommit = options.autoCommit;\n    this.autoCommitMsgCount = options.autoCommitMsgCount;\n    this.autoCommitIntervalMs = options.autoCommitIntervalMs;\n\n    this.autoCommitIntervalTimer = null;\n\n    if (this.autoCommit && this.autoCommitIntervalMs) {\n      this.autoCommitIntervalTimer = setInterval(\n        function () {\n          this.commit();\n        }.bind(this),\n        this.autoCommitIntervalMs\n      );\n    }\n\n    this.messageCount = 0;\n  }\n\n  /**\n   * Extend Transform::on() to act as a pipe if someone consumes data from us.\n   */\n  on (eventName) {\n    if (eventName === 'data') {\n      this.options.passthrough = true;\n    }\n    super.on.apply(this, arguments);\n  }\n\n  /**\n   * Extend Transform::pipe() to act as a pipe if someone consumes data from us.\n   */\n  pipe () {\n    this.options.passthrough = true;\n    super.pipe.apply(this, arguments);\n  }\n\n  _transform (data, encoding, done) {\n    let topicUpdate = {};\n    let self = this;\n    topicUpdate[data.topic] = {};\n    topicUpdate[data.topic][data.partition] = data.offset;\n    self.updateOffsets(topicUpdate);\n    self.messageCount++;\n    const doneWrapper = function () {\n      // We need to act as a through stream if we are not\n      // purely a terminal write stream.\n      if (self.options.passthrough) {\n        return done(null, data);\n      }\n      done();\n    };\n    if (self.autoCommit && self.messageCount === self.autoCommitMsgCount) {\n      self.messageCount = 0;\n      return self.commit(doneWrapper);\n    }\n    doneWrapper();\n  }\n\n  buildTopicData (topicPartions) {\n    return topicPartions.map(function (partion) {\n      if (typeof partion !== 'object') partion = { topic: partion };\n      partion.partition = partion.partition || 0;\n      partion.offset = partion.offset || 0;\n      // Metadata can be arbitrary\n      partion.metadata = 'm';\n      return partion;\n    });\n  }\n\n  /**\n   * @param {Object} topics - An object containing topic offset data keyed by\n   *   topic with keys for partion containing the offset last seen.\n   */\n  updateOffsets (topics, initing) {\n    this.topicPartionOffsets.forEach(function (p) {\n      if (!_.isEmpty(topics[p.topic]) && topics[p.topic][p.partition] !== undefined) {\n        var offset = topics[p.topic][p.partition];\n        if (offset === -1) offset = 0;\n        // Note, we track the offset of the next message we want to see,\n        // not the most recent message we have seen.\n        if (!initing) p.offset = offset + 1;\n        else p.offset = offset;\n      }\n    });\n  }\n\n  /**\n   * Clear the autocommit interval of this commitStream if set.\n   */\n  clearInterval () {\n    clearInterval(this.autoCommitIntervalTimer);\n  }\n\n  commit (cb) {\n    let self = this;\n\n    if (!cb) {\n      cb = function noop () {};\n    }\n\n    if (self.committing) {\n      return cb(null, 'Commit in progress');\n    }\n\n    let topicPartionOffsets = self.topicPartionOffsets;\n\n    let commits = topicPartionOffsets.filter(function (partition) {\n      return partition.offset !== 0;\n    });\n\n    if (commits.length) {\n      self.committing = true;\n      self.client.sendOffsetCommitRequest(self.groupId, commits, function () {\n        self.emit('commitComplete', { group: self.groupId, commits });\n        self.committing = false;\n        cb.apply(this, arguments);\n      });\n    } else {\n      cb(null, 'Nothing to be committed');\n    }\n  }\n}\n\nmodule.exports = CommitStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}