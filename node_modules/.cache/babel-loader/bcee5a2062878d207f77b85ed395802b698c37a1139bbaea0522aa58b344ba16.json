{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/web.immediate.js\");\nconst Client = require('./baseClient');\nconst logger = require('./logging')('kafka-node:KafkaClient');\nconst EventEmitter = require('events');\nconst async = require('async');\nconst retry = require('retry');\nconst assert = require('assert');\nconst _ = require('lodash');\nconst util = require('util');\nconst net = require('net');\nconst BufferList = require('bl');\nconst tls = require('tls');\nconst BrokerWrapper = require('./wrapper/BrokerWrapper');\nconst errors = require('./errors');\nconst validateConfig = require('./utils').validateConfig;\nconst TimeoutError = require('./errors/TimeoutError');\nconst NotControllerError = require('./errors/NotControllerError');\nconst protocol = require('./protocol');\nconst protocolVersions = require('./protocol/protocolVersions');\nconst baseProtocolVersions = protocolVersions.baseSupport;\nconst apiMap = protocolVersions.apiMap;\nconst NestedError = require('nested-error-stacks');\nconst getCodec = require('./codec');\nconst resourceTypeMap = require('./resources').resourceTypeMap;\nconst DEFAULTS = {\n  kafkaHost: 'localhost:9092',\n  connectTimeout: 10000,\n  requestTimeout: 30000,\n  idleConnection: 5 * 60 * 1000,\n  reconnectOnIdle: true,\n  autoConnect: true,\n  versions: {\n    disabled: false,\n    requestTimeout: 500\n  },\n  connectRetryOptions: {\n    retries: 5,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: 60 * 1000,\n    randomize: true\n  },\n  maxAsyncRequests: 10,\n  noAckBatchOptions: null\n};\nconst KafkaClient = function (options) {\n  EventEmitter.call(this); // Intentionally not calling Client to avoid constructor logic\n  this.options = _.defaultsDeep(options || {}, DEFAULTS);\n  this.sslOptions = this.options.sslOptions;\n  this.ssl = !!this.sslOptions;\n  if (this.options.ssl === true) {\n    this.options.ssl = {};\n  }\n  if (this.options.clientId) {\n    validateConfig('clientId', this.options.clientId);\n  }\n  this.clientId = this.options.clientId || 'kafka-node-client';\n  this.noAckBatchOptions = this.options.noAckBatchOptions;\n  this.brokers = {};\n  this.longpollingBrokers = {};\n  this.topicMetadata = {};\n  this.correlationId = 0;\n  this._socketId = 0;\n  /**\n   * @type {Map<any, Map<any, any>>}\n   */\n  this.cbqueue = new Map();\n  this.brokerMetadata = {};\n  this.clusterMetadata = {};\n  this.ready = false;\n  this._timeouts = new Set();\n  this.initialHosts = parseHostList(this.options.kafkaHost);\n  if (this.options.autoConnect) {\n    this.connect();\n  }\n};\nutil.inherits(KafkaClient, Client);\n\n/*\n{ '1001':\n   { jmx_port: -1,\n     timestamp: '1492521177416',\n     endpoints: [ 'PLAINTEXT://127.0.0.1:9092', 'SSL://127.0.0.1:9093' ],\n     host: '127.0.0.1',\n     version: 2,\n     port: '9092',\n     id: '1001' } }\n\n     vs\n\n{ '1001': { nodeId: 1001, host: '127.0.0.1', port: 9093 } }\n\n     */\n\nfunction parseHost(hostString) {\n  const ip = hostString.substring(0, hostString.lastIndexOf(':'));\n  const port = +hostString.substring(hostString.lastIndexOf(':') + 1);\n  const isIpv6 = ip.match(/\\[(.*)\\]/);\n  const host = isIpv6 ? isIpv6[1] : ip;\n  return {\n    host,\n    port\n  };\n}\nfunction parseHostList(hosts) {\n  return hosts.split(',').map(parseHost);\n}\nKafkaClient.prototype.connect = function () {\n  if (this.connecting) {\n    logger.debug('connect request ignored. Client is currently connecting');\n    return;\n  }\n  this.connecting = true;\n  const connect = retry.operation(this.options.connectRetryOptions);\n  connect.attempt(currentAttempt => {\n    if (this.closing) {\n      logger.debug('Client is closing abort retry');\n      connect.stop();\n      return;\n    }\n    logger.debug(`Connect attempt ${currentAttempt}`);\n    async.series([callback => {\n      this.connectToBrokers(this.initialHosts, callback);\n    }, callback => {\n      logger.debug('connected to socket, trying to load initial metadata');\n      this.loadMetadataForTopics([], (error, result) => {\n        if (error) {\n          logger.debug('loadMetadataForTopics after connect failed', error);\n          return callback(error);\n        }\n        this.updateMetadatas(result, true);\n        callback(null);\n      });\n    }], error => {\n      if (connect.retry(error)) {\n        return;\n      }\n      this.connecting = false;\n      if (error) {\n        logger.debug('exhausted retries. Main error', connect.mainError());\n        this.emit('error', connect.mainError());\n        return;\n      }\n      this.ready = true;\n      this.emit('ready');\n    });\n  });\n};\nKafkaClient.prototype.connectToBrokers = function (hosts, callback) {\n  assert(hosts && hosts.length, 'No hosts to connect to');\n  hosts = _.shuffle(hosts);\n  let index = 0;\n  let errors = [];\n  let broker = null;\n  async.doWhilst(callback => {\n    this.connectToBroker(hosts[index++], (error, connectedBroker) => {\n      if (error) {\n        logger.debug('failed to connect because of ', error);\n        errors.push(error);\n        callback(null);\n        return;\n      }\n      errors.length = 0;\n      broker = connectedBroker;\n      callback(null);\n    });\n  }, () => !this.closing && !broker && index < hosts.length, () => {\n    if (this.closing) {\n      return callback(new Error('client is closing'));\n    }\n    if (broker) {\n      return callback(null, broker);\n    }\n    if (errors.length) {\n      callback(errors.pop());\n    } else {\n      callback(new Error('failed to connect to brokers'));\n    }\n  });\n};\nKafkaClient.prototype.connectToBroker = function (broker, callback) {\n  const timeout = this.options.connectTimeout;\n  logger.debug(`Trying to connect to host: ${broker.host} port: ${broker.port}`);\n  let connectTimer = null;\n  callback = _.once(callback);\n  const onError = error => {\n    if (socket.closing) {\n      return;\n    }\n    clearTimeout(connectTimer);\n    connectTimer = null;\n    socket.closing = true;\n    socket.end();\n    socket.destroy();\n    socket.unref();\n    const brokerKey = `${broker.host}:${broker.port}`;\n    delete this.brokers[brokerKey];\n    callback(error);\n  };\n  const brokerWrapper = this.setupBroker(broker.host, broker.port, false, this.brokers);\n  const socket = brokerWrapper.socket;\n  socket.once('connect', () => {\n    logger.debug('broker socket connected %j', broker);\n    this._clearTimeout(connectTimer);\n    callback(null, brokerWrapper);\n  });\n  socket.on('error', function (error) {\n    logger.debug('Socket Error', error);\n    onError(error);\n  });\n  connectTimer = this._createTimeout(function () {\n    logger.debug('Connection timeout error with broker %j', broker);\n    onError(new TimeoutError(`Connection timeout of ${timeout}ms exceeded`));\n  }, timeout);\n};\nKafkaClient.prototype.getController = function (callback) {\n  // Check for cached controller\n  if (this.clusterMetadata.controllerId != null) {\n    var controller = this.brokerMetadata[this.clusterMetadata.controllerId];\n    var broker = this.getBroker(controller.host, controller.port);\n    return callback(null, broker, this.clusterMetadata.controllerId);\n  }\n\n  // If cached controller is not available, refresh metadata\n  this.loadMetadata((error, result) => {\n    if (error) {\n      return callback(error);\n    }\n\n    // No controller will be available if api version request timed out, or if kafka version is less than 0.10.\n    if (!result[1].clusterMetadata || result[1].clusterMetadata.controllerId == null) {\n      return callback(new errors.BrokerNotAvailableError('Controller broker not available'));\n    }\n    this.updateMetadatas(result);\n    var controllerId = result[1].clusterMetadata.controllerId;\n    var controllerMetadata = result[0][controllerId];\n    var broker = this.getBroker(controllerMetadata.host, controllerMetadata.port);\n    if (!broker || !broker.isConnected()) {\n      this.refreshBrokerMetadata();\n      return callback(new errors.BrokerNotAvailableError('Controller broker not available'));\n    }\n    return callback(null, broker, this.clusterMetadata.controllerId);\n  });\n};\nKafkaClient.prototype.getBroker = function (host, port, longpolling) {\n  const brokers = this.getBrokers(longpolling);\n  var addr = host + ':' + port;\n  return brokers[addr] || this.setupBroker(host, port, longpolling, brokers);\n};\nKafkaClient.prototype.setupBroker = function (host, port, longpolling, brokers) {\n  var brokerKey = host + ':' + port;\n  brokers[brokerKey] = this.createBroker(host, port, longpolling);\n  return brokers[brokerKey];\n};\n\n// returns a connected broker\nKafkaClient.prototype.getAvailableBroker = function (callback) {\n  const brokers = this.getBrokers();\n  const connectedBrokers = _.filter(brokers, function (broker) {\n    return broker.isConnected();\n  });\n  if (connectedBrokers.length) {\n    logger.debug('found %d connected broker(s)', connectedBrokers.length);\n    return callback(null, _.sample(connectedBrokers));\n  }\n  let brokersToTry;\n  if (_.isEmpty(brokers)) {\n    brokersToTry = _.values(this.brokerMetadata);\n  } else {\n    const badBrokers = Object.keys(brokers);\n    brokersToTry = _.filter(this.brokerMetadata, function (broker) {\n      return !_.includes(badBrokers, `${broker.host}:${broker.port}`);\n    });\n  }\n  if (_.isEmpty(brokersToTry)) {\n    return callback(new Error('Unable to find available brokers to try'));\n  }\n  this.connectToBrokers(brokersToTry, callback);\n};\nKafkaClient.prototype.refreshBrokers = function () {\n  var self = this;\n  var validBrokers = _.map(this.brokerMetadata, function (broker) {\n    return `${broker.host}:${broker.port}`;\n  });\n  function closeDeadBrokers(brokers) {\n    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);\n    if (deadBrokerKeys.length) {\n      self.closeBrokers(deadBrokerKeys.map(function (key) {\n        var broker = brokers[key];\n        delete brokers[key];\n        return broker;\n      }));\n    }\n  }\n  closeDeadBrokers(this.brokers);\n  closeDeadBrokers(this.longpollingBrokers);\n};\nKafkaClient.prototype.refreshBrokerMetadata = function (callback) {\n  if (this.refreshingMetadata || this.closing) {\n    return;\n  }\n  if (callback == null) {\n    callback = _.noop;\n  }\n  this.refreshingMetadata = true;\n  logger.debug(`${this.clientId} refreshBrokerMetadata()`);\n  async.waterfall([callback => this.getAvailableBroker(callback), (broker, callback) => this.loadMetadataFrom(broker, callback)], (error, result) => {\n    this.refreshingMetadata = false;\n    if (error) {\n      callback(error);\n      return this.emit('error', new NestedError('refreshBrokerMetadata failed', error));\n    }\n    this.updateMetadatas(result, true);\n    this.refreshBrokers();\n    callback(error);\n  });\n};\nKafkaClient.prototype.loadMetadataFrom = function (broker, cb) {\n  assert(broker && broker.isConnected());\n  var correlationId = this.nextId();\n  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, []);\n  this.sendWhenReady(broker, correlationId, request, protocol.decodeMetadataResponse, cb);\n};\nKafkaClient.prototype.setBrokerMetadata = function (brokerMetadata) {\n  assert(brokerMetadata, 'brokerMetadata is empty');\n  const oldBrokerMetadata = this.brokerMetadata;\n  this.brokerMetadata = brokerMetadata;\n  this.brokerMetadataLastUpdate = Date.now();\n  if (!_.isEmpty(oldBrokerMetadata) && !_.isEqual(oldBrokerMetadata, brokerMetadata)) {\n    setImmediate(() => this.emit('brokersChanged'));\n  }\n};\nKafkaClient.prototype.setClusterMetadata = function (clusterMetadata) {\n  assert(clusterMetadata, 'clusterMetadata is empty');\n  this.clusterMetadata = clusterMetadata;\n};\nKafkaClient.prototype.setControllerId = function (controllerId) {\n  if (!this.clusterMetadata) {\n    this.clusterMetadata = {\n      controllerId\n    };\n    return;\n  }\n  this.clusterMetadata.controllerId = controllerId;\n};\nKafkaClient.prototype.updateMetadatas = function (metadatas, replaceTopicMetadata) {\n  assert(metadatas && Array.isArray(metadatas) && metadatas.length === 2, 'metadata format is incorrect');\n  this.setBrokerMetadata(metadatas[0]);\n  if (replaceTopicMetadata) {\n    this.topicMetadata = metadatas[1].metadata;\n  } else {\n    _.extend(this.topicMetadata, metadatas[1].metadata);\n  }\n  if (metadatas[1].clusterMetadata) {\n    this.setClusterMetadata(metadatas[1].clusterMetadata);\n  }\n  logger.debug(`${this.clientId} updated internal metadata`);\n};\nKafkaClient.prototype.brokerForLeader = function (leader, longpolling) {\n  var addr;\n  var brokers = this.getBrokers(longpolling);\n  // If leader is not give, choose the first broker as leader\n  if (typeof leader === 'undefined') {\n    if (!_.isEmpty(brokers)) {\n      addr = Object.keys(brokers)[0];\n      return brokers[addr];\n    } else if (!_.isEmpty(this.brokerMetadata)) {\n      leader = Object.keys(this.brokerMetadata)[0];\n    } else {\n      return;\n    }\n  }\n  var broker = this.brokerMetadata[leader];\n  if (!broker) {\n    return;\n  }\n  addr = broker.host + ':' + broker.port;\n  return brokers[addr] || this.setupBroker(broker.host, broker.port, longpolling, brokers, err => {\n    if (err) {\n      this.emit('error', err);\n    }\n  });\n};\nKafkaClient.prototype.wrapTimeoutIfNeeded = function (socketId, correlationId, callback, overrideTimeout) {\n  if (this.options.requestTimeout === false && overrideTimeout == null) {\n    return callback;\n  }\n  const timeout = overrideTimeout || this.options.requestTimeout;\n  let timeoutId = null;\n  const wrappedFn = function () {\n    clear();\n    callback.apply(null, arguments);\n  };\n  function clear() {\n    clearTimeout(timeoutId);\n    timeoutId = null;\n  }\n  timeoutId = setTimeout(() => {\n    this.unqueueCallback(socketId, correlationId);\n    callback(new TimeoutError(`Request timed out after ${timeout}ms`));\n    callback = _.noop;\n  }, timeout);\n  wrappedFn.timeoutId = timeoutId;\n  return wrappedFn;\n};\nKafkaClient.prototype.queueCallback = function (socket, id, data) {\n  data[1] = this.wrapTimeoutIfNeeded(socket.socketId, id, data[1], data[2]);\n  Client.prototype.queueCallback.call(this, socket, id, data);\n};\nKafkaClient.prototype.getApiVersions = function (broker, cb) {\n  if (!broker || !broker.isConnected()) {\n    return cb(new errors.BrokerNotAvailableError('Broker not available (getApiVersions)'));\n  }\n  logger.debug(`${this.clientId} sending versions request to ${broker.socket.addr}`);\n  const correlationId = this.nextId();\n  const request = protocol.encodeVersionsRequest(this.clientId, correlationId);\n  this.queueCallback(broker.socket, correlationId, [protocol.decodeVersionsResponse, cb, this.options.versions.requestTimeout]);\n  broker.write(request);\n};\nKafkaClient.prototype.getListGroups = function (callback) {\n  if (!this.ready) {\n    return callback(new Error('Client is not ready (getListGroups)'));\n  }\n  const brokers = this.brokerMetadata;\n  async.mapValuesLimit(brokers, this.options.maxAsyncRequests, (brokerMetadata, brokerId, cb) => {\n    const broker = this.brokerForLeader(brokerId);\n    if (!broker || !broker.isConnected()) {\n      return cb(new errors.BrokerNotAvailableError('Broker not available (getListGroups)'));\n    }\n    const correlationId = this.nextId();\n    const request = protocol.encodeListGroups(this.clientId, correlationId);\n    this.sendWhenReady(broker, correlationId, request, protocol.decodeListGroups, cb);\n  }, (err, results) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    results = _.values(results);\n    callback(null, _.merge.apply({}, results));\n  });\n};\nKafkaClient.prototype.getDescribeGroups = function (groups, callback) {\n  if (!this.ready) {\n    return callback(new Error('Client is not ready (getDescribeGroups)'));\n  }\n  async.groupByLimit(groups, this.options.maxAsyncRequests, (group, cb) => {\n    this.sendGroupCoordinatorRequest(group, (err, coordinator) => {\n      cb(err || null, coordinator ? coordinator.coordinatorId : undefined);\n    });\n  }, (err, results) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    async.mapValuesLimit(results, this.options.maxAsyncRequests, (groups, coordinator, cb) => {\n      const broker = this.brokerForLeader(coordinator);\n      if (!broker || !broker.isConnected()) {\n        return cb(new errors.BrokerNotAvailableError('Broker not available (getDescribeGroups)'));\n      }\n      const correlationId = this.nextId();\n      const request = protocol.encodeDescribeGroups(this.clientId, correlationId, groups);\n      this.sendWhenReady(broker, correlationId, request, protocol.decodeDescribeGroups, cb);\n    }, (err, res) => {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, _.reduce(res, (result, describes, broker) => {\n        _.each(describes, (values, consumer) => {\n          result[consumer] = values;\n          result[consumer].brokerId = broker;\n        });\n        return result;\n      }, {}));\n    });\n  });\n};\nKafkaClient.prototype.close = function (callback) {\n  logger.debug('close client');\n  this.closing = true;\n  this.closeBrokers(this.brokers);\n  this.closeBrokers(this.longpollingBrokers);\n  this._clearAllTimeouts();\n  if (callback) {\n    setImmediate(function () {\n      callback(null);\n    });\n  }\n};\nKafkaClient.prototype.initializeBroker = function (broker, callback) {\n  if (!broker || !broker.isConnected()) {\n    return callback(new errors.BrokerNotAvailableError('Broker not available (initializeBroker)'));\n  }\n  if (this.options.versions.disabled) {\n    callback(null);\n    return;\n  }\n  this.getApiVersions(broker, (error, versions) => {\n    if (error) {\n      if (error instanceof TimeoutError) {\n        logger.debug('getApiVersions request timedout probably less than 0.10 using base support');\n        versions = baseProtocolVersions;\n      } else {\n        logger.error('ApiVersions failed with unexpected error', error);\n        callback(error);\n        return;\n      }\n    } else {\n      logger.debug(`Received versions response from ${broker.socket.addr}`);\n    }\n    if (_.isEmpty(versions)) {\n      return callback(new Error(`getApiVersions response was empty for broker: ${broker}`));\n    }\n    logger.debug('setting api support to %j', versions);\n    broker.apiSupport = versions;\n    if (this.options.sasl) {\n      this.saslAuth(broker, err => {\n        if (err) {\n          return callback(err);\n        }\n        callback(null);\n      });\n    } else {\n      callback(null);\n    }\n  });\n};\nKafkaClient.prototype.saslAuth = function (broker, callback) {\n  const mechanism = this.options.sasl.mechanism.toUpperCase();\n  const apiVersion = broker.apiSupport ? broker.apiSupport.saslHandshake.usable : undefined;\n  if (typeof apiVersion !== 'number') {\n    callback(new errors.SaslAuthenticationError(null, 'Broker does not support SASL authentication'));\n    return;\n  }\n  async.waterfall([callback => {\n    logger.debug(`Sending SASL/${mechanism} handshake request to ${broker}`);\n    const correlationId = this.nextId();\n    const request = protocol.encodeSaslHandshakeRequest(this.clientId, correlationId, apiVersion, mechanism);\n    this.queueCallback(broker.socket, correlationId, [protocol.decodeSaslHandshakeResponse, callback]);\n    broker.write(request);\n  }, (enabledMechanisms, callback) => {\n    logger.debug(`Sending SASL/${mechanism} authentication request to ${broker.socket.addr}`);\n    const auth = this.options.sasl;\n    const correlationId = this.nextId();\n    const request = protocol.encodeSaslAuthenticateRequest(this.clientId, correlationId, apiVersion, auth);\n    let decode = protocol.decodeSaslAuthenticateResponse;\n    if (apiVersion === 0) {\n      decode = _.identity;\n      broker.socket.saslAuthCorrelationId = correlationId;\n    }\n    this.queueCallback(broker.socket, correlationId, [decode, callback]);\n    broker.write(request);\n  }], (error, authBytes) => {\n    if (!error) {\n      broker.authenticated = true;\n    }\n\n    // TODO do stuff with authBytes\n    callback(error);\n  });\n};\nKafkaClient.prototype.createBroker = function (host, port, longpolling) {\n  logger.debug(`${this.clientId} createBroker ${host}:${port}`);\n  var self = this;\n  var socket;\n  if (self.ssl) {\n    socket = tls.connect(port, host, self.sslOptions);\n  } else {\n    socket = net.createConnection(port, host);\n  }\n  socket.addr = host + ':' + port;\n  socket.host = host;\n  socket.port = port;\n  socket.socketId = this.nextSocketId();\n  if (longpolling) socket.longpolling = true;\n  socket.on('connect', function () {\n    var lastError = this.error;\n    this.error = null;\n    if (lastError) {\n      this.waiting = false;\n      self.initializeBroker(brokerWrapper, function (error) {\n        if (error) {\n          logger.error('error initializing broker after reconnect', error);\n          return;\n        }\n        const readyEventName = brokerWrapper.getReadyEventName();\n        self.emit(readyEventName);\n        self.emit('reconnect');\n      });\n    } else {\n      self.initializeBroker(brokerWrapper, function (error) {\n        if (error) {\n          logger.error('error initializing broker after connect', error);\n          if (error instanceof errors.SaslAuthenticationError) {\n            self.emit('error', error);\n          }\n          return;\n        }\n        const readyEventName = brokerWrapper.getReadyEventName();\n        self.emit(readyEventName);\n        self.emit('connect');\n      });\n    }\n  });\n  socket.on('error', function (err) {\n    this.error = err;\n    if (!self.connecting) {\n      self.emit('socket_error', err);\n    }\n  });\n  socket.on('close', function (hadError) {\n    self.emit('close', this);\n    logger.debug(`${self.clientId} socket closed ${this.addr} (hadError: ${hadError})`);\n    if (!hadError && self.closing) {\n      logger.debug(`clearing ${this.addr} callback queue without error`);\n      self.clearCallbackQueue(this);\n    } else {\n      let error = this.error;\n      if (!error) {\n        if (self.options.sasl && socket.saslAuthCorrelationId !== undefined) {\n          delete socket.saslAuthCorrelationId;\n          const message = 'Broker closed connection during SASL auth: bad credentials?';\n          error = new errors.SaslAuthenticationError(null, message);\n        } else {\n          error = new errors.BrokerNotAvailableError('Broker not available (socket closed)');\n          if (!self.connecting && !brokerWrapper.isIdle()) {\n            logger.debug(`${self.clientId} schedule refreshBrokerMetadata()`);\n            setImmediate(function () {\n              self.refreshBrokerMetadata();\n            });\n          }\n        }\n      }\n      self.clearCallbackQueue(this, error);\n    }\n    retry(this);\n  });\n  socket.on('end', function () {\n    retry(this);\n  });\n  socket.buffer = new BufferList();\n  socket.on('data', function (data) {\n    socket.buffer.append(data);\n    self.handleReceivedData(socket);\n  });\n  socket.setKeepAlive(true, 60000);\n  const brokerWrapper = new BrokerWrapper(socket, this.noAckBatchOptions, this.options.idleConnection, this.options.sasl);\n  function retry(s) {\n    if (s.retrying || s.closing) return;\n    s.retrying = true;\n    s.retryTimer = setTimeout(function () {\n      if (s.closing) return;\n      if (!self.options.reconnectOnIdle && brokerWrapper.isIdle()) {\n        logger.debug(`${self.clientId} to ${socket.addr} is idle not reconnecting`);\n        s.closing = true;\n        self.deleteDisconnected(brokerWrapper);\n        return;\n      }\n      if (!self.isValidBroker(s)) {\n        logger.debug(`${self.clientId} is not reconnecting to ${s.addr} invalid broker`);\n        return;\n      }\n      logger.debug(`${self.clientId} reconnecting to ${s.addr}`);\n      self.reconnectBroker(s);\n    }, 1000);\n  }\n  return brokerWrapper;\n};\nKafkaClient.prototype.isValidBroker = function ({\n  host,\n  port\n}) {\n  return this.connecting || _(this.brokerMetadata).values().some({\n    host,\n    port\n  });\n};\nKafkaClient.prototype.deleteDisconnected = function (broker) {\n  if (!broker.isConnected()) {\n    const brokers = this.getBrokers(broker.socket.longpolling);\n    const key = broker.socket.addr;\n    assert(brokers[key] === broker);\n    delete brokers[key];\n  }\n};\nKafkaClient.prototype.clearCallbackQueue = function (socket, error) {\n  const socketId = socket.socketId;\n  const queue = this.cbqueue.get(socketId);\n  if (!queue) {\n    return;\n  }\n  queue.forEach(function (handlers) {\n    const cb = handlers[1];\n    if (error) {\n      cb(error);\n    } else if (cb.timeoutId != null) {\n      clearTimeout(cb.timeoutId);\n    }\n  });\n  this.cbqueue.delete(socketId);\n};\n\n/**\n * Fetches metadata for brokers and cluster.\n * This includes an array containing each node (id, host and port).\n * Depending on kafka version, additional cluster information is available (controller id).\n * @param {loadMetadataCallback} cb Function to call once metadata is loaded.\n */\nKafkaClient.prototype.loadMetadata = function (callback) {\n  this.loadMetadataForTopics(null, callback);\n};\n\n/**\n * Fetches metadata for brokers and cluster.\n * This includes an array containing each node (id, host and port). As well as an object\n * containing the topic name, partition, leader number, replica count, and in sync replicas per partition.\n * Depending on kafka version, additional cluster information is available (controller id).\n * @param {Array} topics List of topics to fetch metadata for. An empty array ([]) will fetch all topics.\n * @param {loadMetadataCallback} callback Function to call once metadata is loaded.\n */\nKafkaClient.prototype.loadMetadataForTopics = function (topics, callback) {\n  const broker = this.brokerForLeader();\n  if (!broker || !broker.isConnected()) {\n    return callback(new errors.BrokerNotAvailableError('Broker not available (loadMetadataForTopics)'));\n  }\n  const ensureBrokerReady = (broker, cb) => {\n    if (!broker.isReady()) {\n      logger.debug('missing apiSupport waiting until broker is ready...(loadMetadataForTopics)');\n      this.waitUntilReady(broker, cb);\n    } else {\n      cb(null);\n    }\n  };\n  async.series([cb => {\n    ensureBrokerReady(broker, cb);\n  }, cb => {\n    const broker = this.brokerForLeader();\n    const correlationId = this.nextId();\n    const supportedCoders = getSupportedForRequestType(broker, 'metadata');\n    const request = supportedCoders.encoder(this.clientId, correlationId, topics);\n    this.queueCallback(broker.socket, correlationId, [supportedCoders.decoder, cb]);\n    broker.write(request);\n  }], (err, result) => {\n    callback(err, result[1]);\n  });\n};\n\n/**\n * Creates one or more topics.\n * @param {Array} topics Array of topics with partition and replication factor to create.\n * @param {createTopicsCallback} callback Function to call once operation is completed.\n */\nKafkaClient.prototype.createTopics = function (topics, callback) {\n  // Calls with [string, string, ...] are forwarded to support previous versions\n  if (topics.every(t => typeof t === 'string')) {\n    return Client.prototype.createTopics.apply(this, arguments);\n  }\n  this.sendControllerRequest('createTopics', [topics, this.options.requestTimeout], callback);\n};\nKafkaClient.prototype.topicExists = function (topics, callback) {\n  this.loadMetadataForTopics([], (error, response) => {\n    if (error) {\n      return callback(error);\n    }\n    this.updateMetadatas(response);\n    const missingTopics = _.difference(topics, Object.keys(this.topicMetadata));\n    if (missingTopics.length === 0) {\n      return callback(null);\n    }\n    callback(new errors.TopicsNotExistError(missingTopics));\n  });\n};\nconst encodeMessageSet = protocol.encodeMessageSet;\nconst Message = protocol.Message;\nfunction compress(payloads, callback) {\n  async.each(payloads, buildRequest, callback);\n  function buildRequest(payload, cb) {\n    const attributes = payload.attributes;\n    const codec = getCodec(attributes);\n    if (!codec) return cb(null);\n    const innerSet = encodeMessageSet(payload.messages, 1);\n    codec.encode(innerSet, function (err, message) {\n      if (err) return cb(err);\n      payload.messages = [new Message(0, attributes, payload.key, message)];\n      cb(null);\n    });\n  }\n}\nfunction getSupportedForRequestType(broker, requestType) {\n  assert(!_.isEmpty(broker.apiSupport), 'apiSupport is empty');\n  const brokerSupport = broker.apiSupport[requestType];\n  if (!brokerSupport) {\n    return null;\n  }\n  const usable = brokerSupport.usable;\n  const combo = apiMap[requestType][usable];\n  return {\n    encoder: combo[0],\n    decoder: combo[1]\n  };\n}\nKafkaClient.prototype.waitUntilReady = function (broker, callback) {\n  logger.debug('waitUntilReady ' + broker);\n  let timeoutId = null;\n  const onReady = () => {\n    logger.debug('broker is now ready');\n    if (timeoutId !== null) {\n      this._clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n    callback(null);\n  };\n  const timeout = this.options.requestTimeout;\n  const readyEventName = broker.getReadyEventName();\n  if (timeout !== false) {\n    timeoutId = this._createTimeout(() => {\n      this.removeListener(readyEventName, onReady);\n      this._timeouts.delete(timeoutId);\n      callback(new TimeoutError(`Request timed out after ${timeout}ms`));\n    }, timeout);\n  }\n  this.once(readyEventName, onReady);\n};\nKafkaClient.prototype._clearTimeout = function (timeoutId) {\n  clearTimeout(timeoutId);\n  this._timeouts.delete(timeoutId);\n};\nKafkaClient.prototype._clearAllTimeouts = function () {\n  this._timeouts.forEach(function (timeoutId) {\n    clearTimeout(timeoutId);\n  });\n  this._timeouts.clear();\n};\nKafkaClient.prototype._createTimeout = function (fn, timeout) {\n  const timeoutId = setTimeout(fn, timeout);\n  this._timeouts.add(timeoutId);\n  return timeoutId;\n};\nKafkaClient.prototype.sendRequest = function (request, callback) {\n  const payloads = this.payloadsByLeader(request.data.payloads);\n  const longpolling = request.longpolling;\n  const sendToBroker = async.ensureAsync((payload, leader, callback) => {\n    const broker = this.brokerForLeader(leader, longpolling);\n    if (!broker || !broker.isConnected()) {\n      this.refreshBrokerMetadata();\n      callback(new errors.BrokerNotAvailableError('Broker not available (sendRequest)'));\n      return;\n    }\n    if (!broker.isReady()) {\n      callback(new Error('Broker is not ready'));\n      return;\n    }\n    if (longpolling) {\n      if (broker.socket.waiting) {\n        callback(null);\n        return;\n      }\n      broker.socket.waiting = true;\n    }\n    const correlationId = this.nextId();\n    const coder = getSupportedForRequestType(broker, request.type);\n    const encoder = request.data.args != null ? coder.encoder.apply(null, request.data.args) : coder.encoder;\n    const decoder = request.data.decoderArgs != null ? coder.decoder.apply(null, request.data.decoderArgs) : coder.decoder;\n    const requestData = encoder(this.clientId, correlationId, payload);\n    if (request.data.requireAcks === 0) {\n      broker.writeAsync(requestData);\n      callback(null, {\n        result: 'no ack'\n      });\n    } else {\n      this.queueCallback(broker.socket, correlationId, [decoder, callback]);\n      broker.write(requestData);\n    }\n  });\n  const ensureBrokerReady = async.ensureAsync((leader, callback) => {\n    const broker = this.brokerForLeader(leader, longpolling);\n    if (!broker.isConnected()) {\n      this.refreshBrokerMetadata();\n      callback(new errors.BrokerNotAvailableError('Broker not available (sendRequest -> ensureBrokerReady)'));\n      return;\n    }\n    if (!broker.isReady()) {\n      logger.debug(`missing apiSupport waiting until broker is ready... (sendRequest ${request.type})`);\n      this.waitUntilReady(broker, callback);\n    } else {\n      callback(null);\n    }\n  });\n  async.mapValues(payloads, function (payload, leader, callback) {\n    async.series([function (callback) {\n      ensureBrokerReady(leader, callback);\n    }, function (callback) {\n      sendToBroker(payload, leader, callback);\n    }], function (error, results) {\n      if (error) {\n        return callback(error);\n      }\n      callback(null, _.last(results));\n    });\n  }, callback);\n};\n\n/**\n * Sends a request to a specific broker by id\n */\nKafkaClient.prototype.sendRequestToBroker = function (brokerId, requestType, args, callback) {\n  const brokerMetadata = this.brokerMetadata[brokerId];\n  if (!brokerMetadata) {\n    return callback(new Error('No broker with id ' + brokerId));\n  }\n  const broker = this.getBroker(brokerMetadata.host, brokerMetadata.port);\n  async.waterfall([callback => {\n    if (broker.isReady()) {\n      return callback(null, broker);\n    }\n    this.waitUntilReady(broker, error => {\n      callback(error, broker);\n    });\n  }], (error, result) => {\n    if (error) {\n      return callback(error);\n    }\n    const broker = this.getBroker(brokerMetadata.host, brokerMetadata.port);\n    const correlationId = this.nextId();\n    const coder = getSupportedForRequestType(broker, requestType);\n    if (!coder) {\n      return callback(new errors.ApiNotSupportedError());\n    }\n    args.unshift(this.clientId, correlationId);\n    const encoder = coder.encoder;\n    const decoder = coder.decoder;\n    const request = encoder.apply(null, args);\n    this.sendWhenReady(broker, correlationId, request, decoder, callback);\n  });\n};\nKafkaClient.prototype.leaderLessPayloads = function (payloads) {\n  return _.filter(payloads, payload => !this.hasMetadata(payload.topic, payload.partition));\n};\nKafkaClient.prototype.verifyPayloadsHasLeaders = function (payloads, callback) {\n  const leaderLessPayloads = this.leaderLessPayloads(payloads);\n  if (leaderLessPayloads.length === 0) {\n    return callback(null);\n  }\n  logger.debug('payloads has no leaders! Our metadata could be out of date try refreshingMetadata', leaderLessPayloads);\n  this.refreshMetadata(_.map(leaderLessPayloads, 'topic'), error => {\n    if (error) {\n      return callback(error);\n    }\n    const payloadWithMissingLeaders = this.leaderLessPayloads(payloads);\n    if (payloadWithMissingLeaders.length) {\n      logger.error('leaders are still missing for %j', payloadWithMissingLeaders);\n      callback(new errors.BrokerNotAvailableError('Could not find the leader'));\n    } else {\n      callback(null);\n    }\n  });\n};\nKafkaClient.prototype.wrapControllerCheckIfNeeded = function (requestType, requestArgs, callback) {\n  if (callback.isControllerWrapper) {\n    return callback;\n  }\n  var hasBeenInvoked = false;\n  const wrappedCallback = (error, result) => {\n    if (error instanceof NotControllerError) {\n      this.setControllerId(null);\n      if (!hasBeenInvoked) {\n        hasBeenInvoked = true;\n        this.sendControllerRequest(requestType, requestArgs, wrappedCallback);\n        return;\n      }\n    }\n    callback(error, result);\n  };\n  wrappedCallback.isControllerWrapper = true;\n  return wrappedCallback;\n};\nKafkaClient.prototype.sendControllerRequest = function (requestType, args, callback) {\n  this.getController((error, controller, controllerId) => {\n    if (error) {\n      return callback(error);\n    }\n    const originalArgs = _.clone(args);\n    const originalCallback = callback;\n    callback = this.wrapControllerCheckIfNeeded(requestType, originalArgs, originalCallback);\n    this.sendRequestToBroker(controllerId, requestType, args, callback);\n  });\n};\nKafkaClient.prototype.sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages, callback) {\n  const memberId = consumer.memberId;\n  const generationId = consumer.generationId;\n  if (memberId == null && generationId == null) {\n    Client.prototype.sendFetchRequest.apply(this, arguments);\n    return;\n  }\n  payloads = _.cloneDeep(payloads);\n  function stateValidator(unused, type, message) {\n    const payloadMap = consumer.payloadMap;\n    if (consumer.closing || consumer.connecting || consumer.rebalancing || consumer.memberId !== memberId || consumer.generationId !== generationId) {\n      logger.error('ignoring message due to it being from an old group - memberId: ' + memberId, '!=' + consumer.memberId + ' - generationId: ' + generationId + '!=' + consumer.generationId);\n      return false;\n    }\n    if (type === 'message') {\n      const {\n        topic,\n        partition,\n        offset\n      } = message;\n      if (!payloadMap[topic] || payloadMap[topic][partition] == null) {\n        logger.error('received unexpected message', message, payloadMap);\n        // We should have never received this in the first place\n        return false;\n      }\n      if (offset == null || offset < payloadMap[topic][partition]) {\n        // Kafka may send an older message than we expect (compressed messages, and other unknown reasons)\n        return false;\n      }\n    }\n    return true;\n  }\n  if (callback == null) {\n    callback = _.noop;\n  }\n  async.series([callback => {\n    this.verifyPayloadsHasLeaders(payloads, callback);\n  }, callback => {\n    const request = {\n      type: 'fetch',\n      longpolling: true,\n      data: {\n        payloads: payloads,\n        args: [fetchMaxWaitMs, fetchMinBytes],\n        decoderArgs: [this._createMessageHandler(consumer, stateValidator), maxTickMessages]\n      }\n    };\n    this.sendRequest(request, callback);\n  }], callback);\n};\nKafkaClient.prototype.sendWhenReady = function (broker, correlationId, request, decode, cb) {\n  const doSend = () => {\n    this.queueCallback(broker.socket, correlationId, [decode, cb]);\n    broker.write(request);\n  };\n  if (!broker.isReady()) {\n    this.waitUntilReady(broker, doSend);\n  } else {\n    doSend();\n  }\n};\nKafkaClient.prototype.sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, callback) {\n  async.series([function (callback) {\n    logger.debug('compressing messages if needed');\n    compress(payloads, callback);\n  }, callback => {\n    this.verifyPayloadsHasLeaders(payloads, callback);\n  }, callback => {\n    const request = {\n      type: 'produce',\n      data: {\n        payloads: payloads,\n        args: [requireAcks, ackTimeoutMs],\n        requireAcks: requireAcks\n      }\n    };\n    this.sendRequest(request, callback);\n  }], (err, result) => {\n    if (err) {\n      if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {\n        this.emit('brokersChanged');\n      }\n      callback(err);\n    } else {\n      callback(null, _.chain(result).last().reduce((accu, value) => _.merge(accu, value), {}).value());\n    }\n  });\n};\nKafkaClient.prototype.handleReceivedData = function (socket) {\n  if (socket.saslAuthCorrelationId !== undefined) {\n    if (socket.buffer.length < 4) {\n      // not enough data yet\n      return;\n    }\n    const size = socket.buffer.readInt32BE(0);\n    if (socket.buffer.length - 4 < size) {\n      // still not enough data\n      return;\n    }\n    const resp = socket.buffer.slice(4, 4 + size);\n    this.invokeResponseCallback(socket, socket.saslAuthCorrelationId, resp);\n    delete socket.saslAuthCorrelationId;\n    socket.buffer.consume(size + 4);\n  } else {\n    return Client.prototype.handleReceivedData.call(this, socket);\n  }\n};\nKafkaClient.prototype.describeConfigs = function (payload, callback) {\n  if (!this.ready) {\n    return callback(new Error('Client is not ready (describeConfigs)'));\n  }\n  let err;\n\n  // Broker resource requests must go to the specific node\n  // other requests can go to any node\n  const brokerResourceRequests = [];\n  const nonBrokerResourceRequests = [];\n  _.forEach(payload.resources, function (resource) {\n    if (resourceTypeMap[resource.resourceType] === undefined) {\n      err = new Error(`Unexpected resource type ${resource.resourceType} for resource ${resource.resourceName}`);\n      return false;\n    } else {\n      resource.resourceType = resourceTypeMap[resource.resourceType];\n    }\n    if (resource.resourceType === resourceTypeMap['broker']) {\n      brokerResourceRequests.push(resource);\n    } else {\n      nonBrokerResourceRequests.push(resource);\n    }\n  });\n  if (err) {\n    return callback(err);\n  }\n  async.parallelLimit([cb => {\n    if (nonBrokerResourceRequests.length > 0) {\n      this.sendRequestToAnyBroker('describeConfigs', [{\n        resources: nonBrokerResourceRequests,\n        includeSynonyms: payload.includeSynonyms\n      }], cb);\n    } else {\n      cb(null, []);\n    }\n  }, ...brokerResourceRequests.map(r => {\n    return cb => {\n      this.sendRequestToBroker(r.resourceName, 'describeConfigs', [{\n        resources: [r],\n        includeSynonyms: payload.includeSynonyms\n      }], cb);\n    };\n  })], this.options.maxAsyncRequests, (err, result) => {\n    if (err) {\n      return callback(err);\n    }\n    callback(null, _.flatten(result));\n  });\n};\n\n/**\n * Sends a request to any broker in the cluster\n */\nKafkaClient.prototype.sendRequestToAnyBroker = function (requestType, args, callback) {\n  // For now just select the first broker\n  const brokerId = Object.keys(this.brokerMetadata)[0];\n  this.sendRequestToBroker(brokerId, requestType, args, callback);\n};\nmodule.exports = KafkaClient;","map":{"version":3,"names":["require","Client","logger","EventEmitter","async","retry","assert","_","util","net","BufferList","tls","BrokerWrapper","errors","validateConfig","TimeoutError","NotControllerError","protocol","protocolVersions","baseProtocolVersions","baseSupport","apiMap","NestedError","getCodec","resourceTypeMap","DEFAULTS","kafkaHost","connectTimeout","requestTimeout","idleConnection","reconnectOnIdle","autoConnect","versions","disabled","connectRetryOptions","retries","factor","minTimeout","maxTimeout","randomize","maxAsyncRequests","noAckBatchOptions","KafkaClient","options","call","defaultsDeep","sslOptions","ssl","clientId","brokers","longpollingBrokers","topicMetadata","correlationId","_socketId","cbqueue","Map","brokerMetadata","clusterMetadata","ready","_timeouts","Set","initialHosts","parseHostList","connect","inherits","parseHost","hostString","ip","substring","lastIndexOf","port","isIpv6","match","host","hosts","split","map","prototype","connecting","debug","operation","attempt","currentAttempt","closing","stop","series","callback","connectToBrokers","loadMetadataForTopics","error","result","updateMetadatas","mainError","emit","length","shuffle","index","broker","doWhilst","connectToBroker","connectedBroker","push","Error","pop","timeout","connectTimer","once","onError","socket","clearTimeout","end","destroy","unref","brokerKey","brokerWrapper","setupBroker","_clearTimeout","on","_createTimeout","getController","controllerId","controller","getBroker","loadMetadata","BrokerNotAvailableError","controllerMetadata","isConnected","refreshBrokerMetadata","longpolling","getBrokers","addr","createBroker","getAvailableBroker","connectedBrokers","filter","sample","brokersToTry","isEmpty","values","badBrokers","Object","keys","includes","refreshBrokers","self","validBrokers","closeDeadBrokers","deadBrokerKeys","difference","closeBrokers","key","refreshingMetadata","noop","waterfall","loadMetadataFrom","cb","nextId","request","encodeMetadataRequest","sendWhenReady","decodeMetadataResponse","setBrokerMetadata","oldBrokerMetadata","brokerMetadataLastUpdate","Date","now","isEqual","setImmediate","setClusterMetadata","setControllerId","metadatas","replaceTopicMetadata","Array","isArray","metadata","extend","brokerForLeader","leader","err","wrapTimeoutIfNeeded","socketId","overrideTimeout","timeoutId","wrappedFn","clear","apply","arguments","setTimeout","unqueueCallback","queueCallback","id","data","getApiVersions","encodeVersionsRequest","decodeVersionsResponse","write","getListGroups","mapValuesLimit","brokerId","encodeListGroups","decodeListGroups","results","merge","getDescribeGroups","groups","groupByLimit","group","sendGroupCoordinatorRequest","coordinator","coordinatorId","undefined","encodeDescribeGroups","decodeDescribeGroups","res","reduce","describes","each","consumer","close","_clearAllTimeouts","initializeBroker","apiSupport","sasl","saslAuth","mechanism","toUpperCase","apiVersion","saslHandshake","usable","SaslAuthenticationError","encodeSaslHandshakeRequest","decodeSaslHandshakeResponse","enabledMechanisms","auth","encodeSaslAuthenticateRequest","decode","decodeSaslAuthenticateResponse","identity","saslAuthCorrelationId","authBytes","authenticated","createConnection","nextSocketId","lastError","waiting","readyEventName","getReadyEventName","hadError","clearCallbackQueue","message","isIdle","buffer","append","handleReceivedData","setKeepAlive","s","retrying","retryTimer","deleteDisconnected","isValidBroker","reconnectBroker","some","queue","get","forEach","handlers","delete","topics","ensureBrokerReady","isReady","waitUntilReady","supportedCoders","getSupportedForRequestType","encoder","decoder","createTopics","every","t","sendControllerRequest","topicExists","response","missingTopics","TopicsNotExistError","encodeMessageSet","Message","compress","payloads","buildRequest","payload","attributes","codec","innerSet","messages","encode","requestType","brokerSupport","combo","onReady","removeListener","fn","add","sendRequest","payloadsByLeader","sendToBroker","ensureAsync","coder","type","args","decoderArgs","requestData","requireAcks","writeAsync","mapValues","last","sendRequestToBroker","ApiNotSupportedError","unshift","leaderLessPayloads","hasMetadata","topic","partition","verifyPayloadsHasLeaders","refreshMetadata","payloadWithMissingLeaders","wrapControllerCheckIfNeeded","requestArgs","isControllerWrapper","hasBeenInvoked","wrappedCallback","originalArgs","clone","originalCallback","sendFetchRequest","fetchMaxWaitMs","fetchMinBytes","maxTickMessages","memberId","generationId","cloneDeep","stateValidator","unused","payloadMap","rebalancing","offset","_createMessageHandler","doSend","sendProduceRequest","ackTimeoutMs","chain","accu","value","size","readInt32BE","resp","slice","invokeResponseCallback","consume","describeConfigs","brokerResourceRequests","nonBrokerResourceRequests","resources","resource","resourceType","resourceName","parallelLimit","sendRequestToAnyBroker","includeSynonyms","r","flatten","module","exports"],"sources":["D:/Project/VUEJSSPRING_CRUD_JWT/vue-crud-api-jwt-vuex/node_modules/kafka-node/lib/kafkaClient.js"],"sourcesContent":["'use strict';\n\nconst Client = require('./baseClient');\nconst logger = require('./logging')('kafka-node:KafkaClient');\nconst EventEmitter = require('events');\nconst async = require('async');\nconst retry = require('retry');\nconst assert = require('assert');\nconst _ = require('lodash');\nconst util = require('util');\nconst net = require('net');\nconst BufferList = require('bl');\nconst tls = require('tls');\nconst BrokerWrapper = require('./wrapper/BrokerWrapper');\nconst errors = require('./errors');\nconst validateConfig = require('./utils').validateConfig;\nconst TimeoutError = require('./errors/TimeoutError');\nconst NotControllerError = require('./errors/NotControllerError');\nconst protocol = require('./protocol');\nconst protocolVersions = require('./protocol/protocolVersions');\nconst baseProtocolVersions = protocolVersions.baseSupport;\nconst apiMap = protocolVersions.apiMap;\nconst NestedError = require('nested-error-stacks');\nconst getCodec = require('./codec');\nconst resourceTypeMap = require('./resources').resourceTypeMap;\n\nconst DEFAULTS = {\n  kafkaHost: 'localhost:9092',\n  connectTimeout: 10000,\n  requestTimeout: 30000,\n  idleConnection: 5 * 60 * 1000,\n  reconnectOnIdle: true,\n  autoConnect: true,\n  versions: {\n    disabled: false,\n    requestTimeout: 500\n  },\n  connectRetryOptions: {\n    retries: 5,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: 60 * 1000,\n    randomize: true\n  },\n  maxAsyncRequests: 10,\n  noAckBatchOptions: null\n};\n\nconst KafkaClient = function (options) {\n  EventEmitter.call(this); // Intentionally not calling Client to avoid constructor logic\n  this.options = _.defaultsDeep(options || {}, DEFAULTS);\n\n  this.sslOptions = this.options.sslOptions;\n  this.ssl = !!this.sslOptions;\n\n  if (this.options.ssl === true) {\n    this.options.ssl = {};\n  }\n\n  if (this.options.clientId) {\n    validateConfig('clientId', this.options.clientId);\n  }\n\n  this.clientId = this.options.clientId || 'kafka-node-client';\n  this.noAckBatchOptions = this.options.noAckBatchOptions;\n  this.brokers = {};\n  this.longpollingBrokers = {};\n  this.topicMetadata = {};\n  this.correlationId = 0;\n  this._socketId = 0;\n  /**\n   * @type {Map<any, Map<any, any>>}\n   */\n  this.cbqueue = new Map();\n  this.brokerMetadata = {};\n  this.clusterMetadata = {};\n  this.ready = false;\n  this._timeouts = new Set();\n\n  this.initialHosts = parseHostList(this.options.kafkaHost);\n\n  if (this.options.autoConnect) {\n    this.connect();\n  }\n};\n\nutil.inherits(KafkaClient, Client);\n\n/*\n{ '1001':\n   { jmx_port: -1,\n     timestamp: '1492521177416',\n     endpoints: [ 'PLAINTEXT://127.0.0.1:9092', 'SSL://127.0.0.1:9093' ],\n     host: '127.0.0.1',\n     version: 2,\n     port: '9092',\n     id: '1001' } }\n\n     vs\n\n{ '1001': { nodeId: 1001, host: '127.0.0.1', port: 9093 } }\n\n     */\n\nfunction parseHost (hostString) {\n  const ip = hostString.substring(0, hostString.lastIndexOf(':'));\n  const port = +hostString.substring(hostString.lastIndexOf(':') + 1);\n  const isIpv6 = ip.match(/\\[(.*)\\]/);\n  const host = isIpv6 ? isIpv6[1] : ip;\n  return {\n    host,\n    port\n  };\n}\n\nfunction parseHostList (hosts) {\n  return hosts.split(',').map(parseHost);\n}\n\nKafkaClient.prototype.connect = function () {\n  if (this.connecting) {\n    logger.debug('connect request ignored. Client is currently connecting');\n    return;\n  }\n  this.connecting = true;\n\n  const connect = retry.operation(this.options.connectRetryOptions);\n\n  connect.attempt(currentAttempt => {\n    if (this.closing) {\n      logger.debug('Client is closing abort retry');\n      connect.stop();\n      return;\n    }\n\n    logger.debug(`Connect attempt ${currentAttempt}`);\n\n    async.series(\n      [\n        callback => {\n          this.connectToBrokers(this.initialHosts, callback);\n        },\n\n        callback => {\n          logger.debug('connected to socket, trying to load initial metadata');\n          this.loadMetadataForTopics([], (error, result) => {\n            if (error) {\n              logger.debug('loadMetadataForTopics after connect failed', error);\n              return callback(error);\n            }\n            this.updateMetadatas(result, true);\n            callback(null);\n          });\n        }\n      ],\n      error => {\n        if (connect.retry(error)) {\n          return;\n        }\n\n        this.connecting = false;\n\n        if (error) {\n          logger.debug('exhausted retries. Main error', connect.mainError());\n          this.emit('error', connect.mainError());\n          return;\n        }\n\n        this.ready = true;\n        this.emit('ready');\n      }\n    );\n  });\n};\n\nKafkaClient.prototype.connectToBrokers = function (hosts, callback) {\n  assert(hosts && hosts.length, 'No hosts to connect to');\n  hosts = _.shuffle(hosts);\n  let index = 0;\n  let errors = [];\n  let broker = null;\n  async.doWhilst(\n    callback => {\n      this.connectToBroker(hosts[index++], (error, connectedBroker) => {\n        if (error) {\n          logger.debug('failed to connect because of ', error);\n          errors.push(error);\n          callback(null);\n          return;\n        }\n        errors.length = 0;\n        broker = connectedBroker;\n        callback(null);\n      });\n    },\n    () => !this.closing && !broker && index < hosts.length,\n    () => {\n      if (this.closing) {\n        return callback(new Error('client is closing'));\n      }\n\n      if (broker) {\n        return callback(null, broker);\n      }\n\n      if (errors.length) {\n        callback(errors.pop());\n      } else {\n        callback(new Error('failed to connect to brokers'));\n      }\n    }\n  );\n};\n\nKafkaClient.prototype.connectToBroker = function (broker, callback) {\n  const timeout = this.options.connectTimeout;\n  logger.debug(`Trying to connect to host: ${broker.host} port: ${broker.port}`);\n  let connectTimer = null;\n\n  callback = _.once(callback);\n\n  const onError = error => {\n    if (socket.closing) {\n      return;\n    }\n    clearTimeout(connectTimer);\n    connectTimer = null;\n    socket.closing = true;\n    socket.end();\n    socket.destroy();\n    socket.unref();\n    const brokerKey = `${broker.host}:${broker.port}`;\n    delete this.brokers[brokerKey];\n    callback(error);\n  };\n\n  const brokerWrapper = this.setupBroker(broker.host, broker.port, false, this.brokers);\n  const socket = brokerWrapper.socket;\n\n  socket.once('connect', () => {\n    logger.debug('broker socket connected %j', broker);\n    this._clearTimeout(connectTimer);\n    callback(null, brokerWrapper);\n  });\n\n  socket.on('error', function (error) {\n    logger.debug('Socket Error', error);\n    onError(error);\n  });\n\n  connectTimer = this._createTimeout(function () {\n    logger.debug('Connection timeout error with broker %j', broker);\n    onError(new TimeoutError(`Connection timeout of ${timeout}ms exceeded`));\n  }, timeout);\n};\n\nKafkaClient.prototype.getController = function (callback) {\n  // Check for cached controller\n  if (this.clusterMetadata.controllerId != null) {\n    var controller = this.brokerMetadata[this.clusterMetadata.controllerId];\n    var broker = this.getBroker(controller.host, controller.port);\n\n    return callback(null, broker, this.clusterMetadata.controllerId);\n  }\n\n  // If cached controller is not available, refresh metadata\n  this.loadMetadata((error, result) => {\n    if (error) {\n      return callback(error);\n    }\n\n    // No controller will be available if api version request timed out, or if kafka version is less than 0.10.\n    if (!result[1].clusterMetadata || result[1].clusterMetadata.controllerId == null) {\n      return callback(new errors.BrokerNotAvailableError('Controller broker not available'));\n    }\n\n    this.updateMetadatas(result);\n\n    var controllerId = result[1].clusterMetadata.controllerId;\n    var controllerMetadata = result[0][controllerId];\n\n    var broker = this.getBroker(controllerMetadata.host, controllerMetadata.port);\n\n    if (!broker || !broker.isConnected()) {\n      this.refreshBrokerMetadata();\n      return callback(new errors.BrokerNotAvailableError('Controller broker not available'));\n    }\n\n    return callback(null, broker, this.clusterMetadata.controllerId);\n  });\n};\n\nKafkaClient.prototype.getBroker = function (host, port, longpolling) {\n  const brokers = this.getBrokers(longpolling);\n\n  var addr = host + ':' + port;\n  return brokers[addr] || this.setupBroker(host, port, longpolling, brokers);\n};\n\nKafkaClient.prototype.setupBroker = function (host, port, longpolling, brokers) {\n  var brokerKey = host + ':' + port;\n  brokers[brokerKey] = this.createBroker(host, port, longpolling);\n  return brokers[brokerKey];\n};\n\n// returns a connected broker\nKafkaClient.prototype.getAvailableBroker = function (callback) {\n  const brokers = this.getBrokers();\n  const connectedBrokers = _.filter(brokers, function (broker) {\n    return broker.isConnected();\n  });\n\n  if (connectedBrokers.length) {\n    logger.debug('found %d connected broker(s)', connectedBrokers.length);\n    return callback(null, _.sample(connectedBrokers));\n  }\n\n  let brokersToTry;\n\n  if (_.isEmpty(brokers)) {\n    brokersToTry = _.values(this.brokerMetadata);\n  } else {\n    const badBrokers = Object.keys(brokers);\n    brokersToTry = _.filter(this.brokerMetadata, function (broker) {\n      return !_.includes(badBrokers, `${broker.host}:${broker.port}`);\n    });\n  }\n\n  if (_.isEmpty(brokersToTry)) {\n    return callback(new Error('Unable to find available brokers to try'));\n  }\n\n  this.connectToBrokers(brokersToTry, callback);\n};\n\nKafkaClient.prototype.refreshBrokers = function () {\n  var self = this;\n  var validBrokers = _.map(this.brokerMetadata, function (broker) {\n    return `${broker.host}:${broker.port}`;\n  });\n\n  function closeDeadBrokers (brokers) {\n    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);\n    if (deadBrokerKeys.length) {\n      self.closeBrokers(\n        deadBrokerKeys.map(function (key) {\n          var broker = brokers[key];\n          delete brokers[key];\n          return broker;\n        })\n      );\n    }\n  }\n\n  closeDeadBrokers(this.brokers);\n  closeDeadBrokers(this.longpollingBrokers);\n};\n\nKafkaClient.prototype.refreshBrokerMetadata = function (callback) {\n  if (this.refreshingMetadata || this.closing) {\n    return;\n  }\n\n  if (callback == null) {\n    callback = _.noop;\n  }\n\n  this.refreshingMetadata = true;\n\n  logger.debug(`${this.clientId} refreshBrokerMetadata()`);\n\n  async.waterfall(\n    [callback => this.getAvailableBroker(callback), (broker, callback) => this.loadMetadataFrom(broker, callback)],\n    (error, result) => {\n      this.refreshingMetadata = false;\n      if (error) {\n        callback(error);\n        return this.emit('error', new NestedError('refreshBrokerMetadata failed', error));\n      }\n      this.updateMetadatas(result, true);\n      this.refreshBrokers();\n      callback(error);\n    }\n  );\n};\n\nKafkaClient.prototype.loadMetadataFrom = function (broker, cb) {\n  assert(broker && broker.isConnected());\n  var correlationId = this.nextId();\n  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, []);\n\n  this.sendWhenReady(broker, correlationId, request, protocol.decodeMetadataResponse, cb);\n};\n\nKafkaClient.prototype.setBrokerMetadata = function (brokerMetadata) {\n  assert(brokerMetadata, 'brokerMetadata is empty');\n  const oldBrokerMetadata = this.brokerMetadata;\n  this.brokerMetadata = brokerMetadata;\n  this.brokerMetadataLastUpdate = Date.now();\n\n  if (!_.isEmpty(oldBrokerMetadata) && !_.isEqual(oldBrokerMetadata, brokerMetadata)) {\n    setImmediate(() => this.emit('brokersChanged'));\n  }\n};\n\nKafkaClient.prototype.setClusterMetadata = function (clusterMetadata) {\n  assert(clusterMetadata, 'clusterMetadata is empty');\n  this.clusterMetadata = clusterMetadata;\n};\n\nKafkaClient.prototype.setControllerId = function (controllerId) {\n  if (!this.clusterMetadata) {\n    this.clusterMetadata = {\n      controllerId\n    };\n\n    return;\n  }\n  this.clusterMetadata.controllerId = controllerId;\n};\n\nKafkaClient.prototype.updateMetadatas = function (metadatas, replaceTopicMetadata) {\n  assert(metadatas && Array.isArray(metadatas) && metadatas.length === 2, 'metadata format is incorrect');\n  this.setBrokerMetadata(metadatas[0]);\n  if (replaceTopicMetadata) {\n    this.topicMetadata = metadatas[1].metadata;\n  } else {\n    _.extend(this.topicMetadata, metadatas[1].metadata);\n  }\n\n  if (metadatas[1].clusterMetadata) {\n    this.setClusterMetadata(metadatas[1].clusterMetadata);\n  }\n  logger.debug(`${this.clientId} updated internal metadata`);\n};\n\nKafkaClient.prototype.brokerForLeader = function (leader, longpolling) {\n  var addr;\n  var brokers = this.getBrokers(longpolling);\n  // If leader is not give, choose the first broker as leader\n  if (typeof leader === 'undefined') {\n    if (!_.isEmpty(brokers)) {\n      addr = Object.keys(brokers)[0];\n      return brokers[addr];\n    } else if (!_.isEmpty(this.brokerMetadata)) {\n      leader = Object.keys(this.brokerMetadata)[0];\n    } else {\n      return;\n    }\n  }\n\n  var broker = this.brokerMetadata[leader];\n\n  if (!broker) {\n    return;\n  }\n\n  addr = broker.host + ':' + broker.port;\n\n  return (\n    brokers[addr] ||\n    this.setupBroker(broker.host, broker.port, longpolling, brokers, err => {\n      if (err) {\n        this.emit('error', err);\n      }\n    })\n  );\n};\n\nKafkaClient.prototype.wrapTimeoutIfNeeded = function (socketId, correlationId, callback, overrideTimeout) {\n  if (this.options.requestTimeout === false && overrideTimeout == null) {\n    return callback;\n  }\n\n  const timeout = overrideTimeout || this.options.requestTimeout;\n\n  let timeoutId = null;\n\n  const wrappedFn = function () {\n    clear();\n    callback.apply(null, arguments);\n  };\n\n  function clear () {\n    clearTimeout(timeoutId);\n    timeoutId = null;\n  }\n\n  timeoutId = setTimeout(() => {\n    this.unqueueCallback(socketId, correlationId);\n    callback(new TimeoutError(`Request timed out after ${timeout}ms`));\n    callback = _.noop;\n  }, timeout);\n\n  wrappedFn.timeoutId = timeoutId;\n\n  return wrappedFn;\n};\n\nKafkaClient.prototype.queueCallback = function (socket, id, data) {\n  data[1] = this.wrapTimeoutIfNeeded(socket.socketId, id, data[1], data[2]);\n  Client.prototype.queueCallback.call(this, socket, id, data);\n};\n\nKafkaClient.prototype.getApiVersions = function (broker, cb) {\n  if (!broker || !broker.isConnected()) {\n    return cb(new errors.BrokerNotAvailableError('Broker not available (getApiVersions)'));\n  }\n\n  logger.debug(`${this.clientId} sending versions request to ${broker.socket.addr}`);\n\n  const correlationId = this.nextId();\n  const request = protocol.encodeVersionsRequest(this.clientId, correlationId);\n\n  this.queueCallback(broker.socket, correlationId, [\n    protocol.decodeVersionsResponse,\n    cb,\n    this.options.versions.requestTimeout\n  ]);\n  broker.write(request);\n};\n\nKafkaClient.prototype.getListGroups = function (callback) {\n  if (!this.ready) {\n    return callback(new Error('Client is not ready (getListGroups)'));\n  }\n  const brokers = this.brokerMetadata;\n  async.mapValuesLimit(\n    brokers,\n    this.options.maxAsyncRequests,\n    (brokerMetadata, brokerId, cb) => {\n      const broker = this.brokerForLeader(brokerId);\n      if (!broker || !broker.isConnected()) {\n        return cb(new errors.BrokerNotAvailableError('Broker not available (getListGroups)'));\n      }\n\n      const correlationId = this.nextId();\n      const request = protocol.encodeListGroups(this.clientId, correlationId);\n      this.sendWhenReady(broker, correlationId, request, protocol.decodeListGroups, cb);\n    },\n    (err, results) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      results = _.values(results);\n      callback(null, _.merge.apply({}, results));\n    }\n  );\n};\n\nKafkaClient.prototype.getDescribeGroups = function (groups, callback) {\n  if (!this.ready) {\n    return callback(new Error('Client is not ready (getDescribeGroups)'));\n  }\n\n  async.groupByLimit(\n    groups,\n    this.options.maxAsyncRequests,\n    (group, cb) => {\n      this.sendGroupCoordinatorRequest(group, (err, coordinator) => {\n        cb(err || null, coordinator ? coordinator.coordinatorId : undefined);\n      });\n    },\n    (err, results) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      async.mapValuesLimit(\n        results,\n        this.options.maxAsyncRequests,\n        (groups, coordinator, cb) => {\n          const broker = this.brokerForLeader(coordinator);\n          if (!broker || !broker.isConnected()) {\n            return cb(new errors.BrokerNotAvailableError('Broker not available (getDescribeGroups)'));\n          }\n\n          const correlationId = this.nextId();\n          const request = protocol.encodeDescribeGroups(this.clientId, correlationId, groups);\n          this.sendWhenReady(broker, correlationId, request, protocol.decodeDescribeGroups, cb);\n        },\n        (err, res) => {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(\n            null,\n            _.reduce(\n              res,\n              (result, describes, broker) => {\n                _.each(describes, (values, consumer) => {\n                  result[consumer] = values;\n                  result[consumer].brokerId = broker;\n                });\n                return result;\n              },\n              {}\n            )\n          );\n        }\n      );\n    }\n  );\n};\n\nKafkaClient.prototype.close = function (callback) {\n  logger.debug('close client');\n  this.closing = true;\n  this.closeBrokers(this.brokers);\n  this.closeBrokers(this.longpollingBrokers);\n  this._clearAllTimeouts();\n  if (callback) {\n    setImmediate(function () {\n      callback(null);\n    });\n  }\n};\n\nKafkaClient.prototype.initializeBroker = function (broker, callback) {\n  if (!broker || !broker.isConnected()) {\n    return callback(new errors.BrokerNotAvailableError('Broker not available (initializeBroker)'));\n  }\n\n  if (this.options.versions.disabled) {\n    callback(null);\n    return;\n  }\n\n  this.getApiVersions(broker, (error, versions) => {\n    if (error) {\n      if (error instanceof TimeoutError) {\n        logger.debug('getApiVersions request timedout probably less than 0.10 using base support');\n        versions = baseProtocolVersions;\n      } else {\n        logger.error('ApiVersions failed with unexpected error', error);\n        callback(error);\n        return;\n      }\n    } else {\n      logger.debug(`Received versions response from ${broker.socket.addr}`);\n    }\n\n    if (_.isEmpty(versions)) {\n      return callback(new Error(`getApiVersions response was empty for broker: ${broker}`));\n    }\n\n    logger.debug('setting api support to %j', versions);\n    broker.apiSupport = versions;\n\n    if (this.options.sasl) {\n      this.saslAuth(broker, err => {\n        if (err) {\n          return callback(err);\n        }\n        callback(null);\n      });\n    } else {\n      callback(null);\n    }\n  });\n};\n\nKafkaClient.prototype.saslAuth = function (broker, callback) {\n  const mechanism = this.options.sasl.mechanism.toUpperCase();\n  const apiVersion = broker.apiSupport ? broker.apiSupport.saslHandshake.usable : undefined;\n  if (typeof apiVersion !== 'number') {\n    callback(new errors.SaslAuthenticationError(null, 'Broker does not support SASL authentication'));\n    return;\n  }\n\n  async.waterfall(\n    [\n      callback => {\n        logger.debug(`Sending SASL/${mechanism} handshake request to ${broker}`);\n\n        const correlationId = this.nextId();\n        const request = protocol.encodeSaslHandshakeRequest(this.clientId, correlationId, apiVersion, mechanism);\n\n        this.queueCallback(broker.socket, correlationId, [protocol.decodeSaslHandshakeResponse, callback]);\n        broker.write(request);\n      },\n      (enabledMechanisms, callback) => {\n        logger.debug(`Sending SASL/${mechanism} authentication request to ${broker.socket.addr}`);\n\n        const auth = this.options.sasl;\n        const correlationId = this.nextId();\n        const request = protocol.encodeSaslAuthenticateRequest(this.clientId, correlationId, apiVersion, auth);\n\n        let decode = protocol.decodeSaslAuthenticateResponse;\n        if (apiVersion === 0) {\n          decode = _.identity;\n          broker.socket.saslAuthCorrelationId = correlationId;\n        }\n        this.queueCallback(broker.socket, correlationId, [decode, callback]);\n        broker.write(request);\n      }\n    ],\n    (error, authBytes) => {\n      if (!error) {\n        broker.authenticated = true;\n      }\n\n      // TODO do stuff with authBytes\n      callback(error);\n    }\n  );\n};\n\nKafkaClient.prototype.createBroker = function (host, port, longpolling) {\n  logger.debug(`${this.clientId} createBroker ${host}:${port}`);\n  var self = this;\n  var socket;\n  if (self.ssl) {\n    socket = tls.connect(port, host, self.sslOptions);\n  } else {\n    socket = net.createConnection(port, host);\n  }\n  socket.addr = host + ':' + port;\n  socket.host = host;\n  socket.port = port;\n  socket.socketId = this.nextSocketId();\n  if (longpolling) socket.longpolling = true;\n\n  socket.on('connect', function () {\n    var lastError = this.error;\n    this.error = null;\n    if (lastError) {\n      this.waiting = false;\n\n      self.initializeBroker(brokerWrapper, function (error) {\n        if (error) {\n          logger.error('error initializing broker after reconnect', error);\n          return;\n        }\n        const readyEventName = brokerWrapper.getReadyEventName();\n        self.emit(readyEventName);\n        self.emit('reconnect');\n      });\n    } else {\n      self.initializeBroker(brokerWrapper, function (error) {\n        if (error) {\n          logger.error('error initializing broker after connect', error);\n          if (error instanceof errors.SaslAuthenticationError) {\n            self.emit('error', error);\n          }\n          return;\n        }\n\n        const readyEventName = brokerWrapper.getReadyEventName();\n        self.emit(readyEventName);\n        self.emit('connect');\n      });\n    }\n  });\n  socket.on('error', function (err) {\n    this.error = err;\n    if (!self.connecting) {\n      self.emit('socket_error', err);\n    }\n  });\n  socket.on('close', function (hadError) {\n    self.emit('close', this);\n    logger.debug(`${self.clientId} socket closed ${this.addr} (hadError: ${hadError})`);\n    if (!hadError && self.closing) {\n      logger.debug(`clearing ${this.addr} callback queue without error`);\n      self.clearCallbackQueue(this);\n    } else {\n      let error = this.error;\n      if (!error) {\n        if (self.options.sasl && socket.saslAuthCorrelationId !== undefined) {\n          delete socket.saslAuthCorrelationId;\n          const message = 'Broker closed connection during SASL auth: bad credentials?';\n          error = new errors.SaslAuthenticationError(null, message);\n        } else {\n          error = new errors.BrokerNotAvailableError('Broker not available (socket closed)');\n          if (!self.connecting && !brokerWrapper.isIdle()) {\n            logger.debug(`${self.clientId} schedule refreshBrokerMetadata()`);\n            setImmediate(function () {\n              self.refreshBrokerMetadata();\n            });\n          }\n        }\n      }\n      self.clearCallbackQueue(this, error);\n    }\n    retry(this);\n  });\n  socket.on('end', function () {\n    retry(this);\n  });\n  socket.buffer = new BufferList();\n  socket.on('data', function (data) {\n    socket.buffer.append(data);\n    self.handleReceivedData(socket);\n  });\n  socket.setKeepAlive(true, 60000);\n\n  const brokerWrapper = new BrokerWrapper(\n    socket,\n    this.noAckBatchOptions,\n    this.options.idleConnection,\n    this.options.sasl\n  );\n\n  function retry (s) {\n    if (s.retrying || s.closing) return;\n    s.retrying = true;\n    s.retryTimer = setTimeout(function () {\n      if (s.closing) return;\n      if (!self.options.reconnectOnIdle && brokerWrapper.isIdle()) {\n        logger.debug(`${self.clientId} to ${socket.addr} is idle not reconnecting`);\n        s.closing = true;\n        self.deleteDisconnected(brokerWrapper);\n        return;\n      }\n\n      if (!self.isValidBroker(s)) {\n        logger.debug(`${self.clientId} is not reconnecting to ${s.addr} invalid broker`);\n        return;\n      }\n\n      logger.debug(`${self.clientId} reconnecting to ${s.addr}`);\n      self.reconnectBroker(s);\n    }, 1000);\n  }\n  return brokerWrapper;\n};\n\nKafkaClient.prototype.isValidBroker = function ({ host, port }) {\n  return (\n    this.connecting ||\n    _(this.brokerMetadata)\n      .values()\n      .some({ host, port })\n  );\n};\n\nKafkaClient.prototype.deleteDisconnected = function (broker) {\n  if (!broker.isConnected()) {\n    const brokers = this.getBrokers(broker.socket.longpolling);\n    const key = broker.socket.addr;\n    assert(brokers[key] === broker);\n    delete brokers[key];\n  }\n};\n\nKafkaClient.prototype.clearCallbackQueue = function (socket, error) {\n  const socketId = socket.socketId;\n  const queue = this.cbqueue.get(socketId);\n  if (!queue) {\n    return;\n  }\n\n  queue.forEach(function (handlers) {\n    const cb = handlers[1];\n    if (error) {\n      cb(error);\n    } else if (cb.timeoutId != null) {\n      clearTimeout(cb.timeoutId);\n    }\n  });\n\n  this.cbqueue.delete(socketId);\n};\n\n/**\n * Fetches metadata for brokers and cluster.\n * This includes an array containing each node (id, host and port).\n * Depending on kafka version, additional cluster information is available (controller id).\n * @param {loadMetadataCallback} cb Function to call once metadata is loaded.\n */\nKafkaClient.prototype.loadMetadata = function (callback) {\n  this.loadMetadataForTopics(null, callback);\n};\n\n/**\n * Fetches metadata for brokers and cluster.\n * This includes an array containing each node (id, host and port). As well as an object\n * containing the topic name, partition, leader number, replica count, and in sync replicas per partition.\n * Depending on kafka version, additional cluster information is available (controller id).\n * @param {Array} topics List of topics to fetch metadata for. An empty array ([]) will fetch all topics.\n * @param {loadMetadataCallback} callback Function to call once metadata is loaded.\n */\nKafkaClient.prototype.loadMetadataForTopics = function (topics, callback) {\n  const broker = this.brokerForLeader();\n\n  if (!broker || !broker.isConnected()) {\n    return callback(new errors.BrokerNotAvailableError('Broker not available (loadMetadataForTopics)'));\n  }\n\n  const ensureBrokerReady = (broker, cb) => {\n    if (!broker.isReady()) {\n      logger.debug('missing apiSupport waiting until broker is ready...(loadMetadataForTopics)');\n      this.waitUntilReady(broker, cb);\n    } else {\n      cb(null);\n    }\n  };\n\n  async.series(\n    [\n      cb => {\n        ensureBrokerReady(broker, cb);\n      },\n      cb => {\n        const broker = this.brokerForLeader();\n        const correlationId = this.nextId();\n        const supportedCoders = getSupportedForRequestType(broker, 'metadata');\n        const request = supportedCoders.encoder(this.clientId, correlationId, topics);\n\n        this.queueCallback(broker.socket, correlationId, [supportedCoders.decoder, cb]);\n        broker.write(request);\n      }\n    ],\n    (err, result) => {\n      callback(err, result[1]);\n    }\n  );\n};\n\n/**\n * Creates one or more topics.\n * @param {Array} topics Array of topics with partition and replication factor to create.\n * @param {createTopicsCallback} callback Function to call once operation is completed.\n */\nKafkaClient.prototype.createTopics = function (topics, callback) {\n  // Calls with [string, string, ...] are forwarded to support previous versions\n  if (topics.every(t => typeof t === 'string')) {\n    return Client.prototype.createTopics.apply(this, arguments);\n  }\n\n  this.sendControllerRequest('createTopics', [topics, this.options.requestTimeout], callback);\n};\n\nKafkaClient.prototype.topicExists = function (topics, callback) {\n  this.loadMetadataForTopics([], (error, response) => {\n    if (error) {\n      return callback(error);\n    }\n    this.updateMetadatas(response);\n    const missingTopics = _.difference(topics, Object.keys(this.topicMetadata));\n    if (missingTopics.length === 0) {\n      return callback(null);\n    }\n    callback(new errors.TopicsNotExistError(missingTopics));\n  });\n};\n\nconst encodeMessageSet = protocol.encodeMessageSet;\nconst Message = protocol.Message;\n\nfunction compress (payloads, callback) {\n  async.each(payloads, buildRequest, callback);\n\n  function buildRequest (payload, cb) {\n    const attributes = payload.attributes;\n    const codec = getCodec(attributes);\n\n    if (!codec) return cb(null);\n\n    const innerSet = encodeMessageSet(payload.messages, 1);\n    codec.encode(innerSet, function (err, message) {\n      if (err) return cb(err);\n      payload.messages = [new Message(0, attributes, payload.key, message)];\n      cb(null);\n    });\n  }\n}\n\nfunction getSupportedForRequestType (broker, requestType) {\n  assert(!_.isEmpty(broker.apiSupport), 'apiSupport is empty');\n  const brokerSupport = broker.apiSupport[requestType];\n\n  if (!brokerSupport) {\n    return null;\n  }\n\n  const usable = brokerSupport.usable;\n\n  const combo = apiMap[requestType][usable];\n  return {\n    encoder: combo[0],\n    decoder: combo[1]\n  };\n}\n\nKafkaClient.prototype.waitUntilReady = function (broker, callback) {\n  logger.debug('waitUntilReady ' + broker);\n  let timeoutId = null;\n\n  const onReady = () => {\n    logger.debug('broker is now ready');\n\n    if (timeoutId !== null) {\n      this._clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    callback(null);\n  };\n\n  const timeout = this.options.requestTimeout;\n  const readyEventName = broker.getReadyEventName();\n\n  if (timeout !== false) {\n    timeoutId = this._createTimeout(() => {\n      this.removeListener(readyEventName, onReady);\n      this._timeouts.delete(timeoutId);\n      callback(new TimeoutError(`Request timed out after ${timeout}ms`));\n    }, timeout);\n  }\n\n  this.once(readyEventName, onReady);\n};\n\nKafkaClient.prototype._clearTimeout = function (timeoutId) {\n  clearTimeout(timeoutId);\n  this._timeouts.delete(timeoutId);\n};\n\nKafkaClient.prototype._clearAllTimeouts = function () {\n  this._timeouts.forEach(function (timeoutId) {\n    clearTimeout(timeoutId);\n  });\n\n  this._timeouts.clear();\n};\n\nKafkaClient.prototype._createTimeout = function (fn, timeout) {\n  const timeoutId = setTimeout(fn, timeout);\n  this._timeouts.add(timeoutId);\n  return timeoutId;\n};\n\nKafkaClient.prototype.sendRequest = function (request, callback) {\n  const payloads = this.payloadsByLeader(request.data.payloads);\n  const longpolling = request.longpolling;\n\n  const sendToBroker = async.ensureAsync((payload, leader, callback) => {\n    const broker = this.brokerForLeader(leader, longpolling);\n    if (!broker || !broker.isConnected()) {\n      this.refreshBrokerMetadata();\n      callback(new errors.BrokerNotAvailableError('Broker not available (sendRequest)'));\n      return;\n    }\n\n    if (!broker.isReady()) {\n      callback(new Error('Broker is not ready'));\n      return;\n    }\n\n    if (longpolling) {\n      if (broker.socket.waiting) {\n        callback(null);\n        return;\n      }\n      broker.socket.waiting = true;\n    }\n\n    const correlationId = this.nextId();\n    const coder = getSupportedForRequestType(broker, request.type);\n\n    const encoder = request.data.args != null ? coder.encoder.apply(null, request.data.args) : coder.encoder;\n    const decoder =\n      request.data.decoderArgs != null ? coder.decoder.apply(null, request.data.decoderArgs) : coder.decoder;\n\n    const requestData = encoder(this.clientId, correlationId, payload);\n\n    if (request.data.requireAcks === 0) {\n      broker.writeAsync(requestData);\n      callback(null, { result: 'no ack' });\n    } else {\n      this.queueCallback(broker.socket, correlationId, [decoder, callback]);\n      broker.write(requestData);\n    }\n  });\n\n  const ensureBrokerReady = async.ensureAsync((leader, callback) => {\n    const broker = this.brokerForLeader(leader, longpolling);\n    if (!broker.isConnected()) {\n      this.refreshBrokerMetadata();\n      callback(new errors.BrokerNotAvailableError('Broker not available (sendRequest -> ensureBrokerReady)'));\n      return;\n    }\n    if (!broker.isReady()) {\n      logger.debug(`missing apiSupport waiting until broker is ready... (sendRequest ${request.type})`);\n      this.waitUntilReady(broker, callback);\n    } else {\n      callback(null);\n    }\n  });\n\n  async.mapValues(\n    payloads,\n    function (payload, leader, callback) {\n      async.series(\n        [\n          function (callback) {\n            ensureBrokerReady(leader, callback);\n          },\n          function (callback) {\n            sendToBroker(payload, leader, callback);\n          }\n        ],\n        function (error, results) {\n          if (error) {\n            return callback(error);\n          }\n          callback(null, _.last(results));\n        }\n      );\n    },\n    callback\n  );\n};\n\n/**\n * Sends a request to a specific broker by id\n */\nKafkaClient.prototype.sendRequestToBroker = function (brokerId, requestType, args, callback) {\n  const brokerMetadata = this.brokerMetadata[brokerId];\n\n  if (!brokerMetadata) {\n    return callback(new Error('No broker with id ' + brokerId));\n  }\n\n  const broker = this.getBroker(brokerMetadata.host, brokerMetadata.port);\n\n  async.waterfall(\n    [\n      callback => {\n        if (broker.isReady()) {\n          return callback(null, broker);\n        }\n\n        this.waitUntilReady(broker, error => {\n          callback(error, broker);\n        });\n      }\n    ],\n    (error, result) => {\n      if (error) {\n        return callback(error);\n      }\n\n      const broker = this.getBroker(brokerMetadata.host, brokerMetadata.port);\n      const correlationId = this.nextId();\n      const coder = getSupportedForRequestType(broker, requestType);\n\n      if (!coder) {\n        return callback(new errors.ApiNotSupportedError());\n      }\n\n      args.unshift(this.clientId, correlationId);\n      const encoder = coder.encoder;\n      const decoder = coder.decoder;\n      const request = encoder.apply(null, args);\n\n      this.sendWhenReady(broker, correlationId, request, decoder, callback);\n    }\n  );\n};\n\nKafkaClient.prototype.leaderLessPayloads = function (payloads) {\n  return _.filter(payloads, payload => !this.hasMetadata(payload.topic, payload.partition));\n};\n\nKafkaClient.prototype.verifyPayloadsHasLeaders = function (payloads, callback) {\n  const leaderLessPayloads = this.leaderLessPayloads(payloads);\n\n  if (leaderLessPayloads.length === 0) {\n    return callback(null);\n  }\n  logger.debug('payloads has no leaders! Our metadata could be out of date try refreshingMetadata', leaderLessPayloads);\n  this.refreshMetadata(_.map(leaderLessPayloads, 'topic'), error => {\n    if (error) {\n      return callback(error);\n    }\n    const payloadWithMissingLeaders = this.leaderLessPayloads(payloads);\n    if (payloadWithMissingLeaders.length) {\n      logger.error('leaders are still missing for %j', payloadWithMissingLeaders);\n      callback(new errors.BrokerNotAvailableError('Could not find the leader'));\n    } else {\n      callback(null);\n    }\n  });\n};\n\nKafkaClient.prototype.wrapControllerCheckIfNeeded = function (requestType, requestArgs, callback) {\n  if (callback.isControllerWrapper) {\n    return callback;\n  }\n\n  var hasBeenInvoked = false;\n\n  const wrappedCallback = (error, result) => {\n    if (error instanceof NotControllerError) {\n      this.setControllerId(null);\n\n      if (!hasBeenInvoked) {\n        hasBeenInvoked = true;\n        this.sendControllerRequest(requestType, requestArgs, wrappedCallback);\n        return;\n      }\n    }\n\n    callback(error, result);\n  };\n\n  wrappedCallback.isControllerWrapper = true;\n\n  return wrappedCallback;\n};\n\nKafkaClient.prototype.sendControllerRequest = function (requestType, args, callback) {\n  this.getController((error, controller, controllerId) => {\n    if (error) {\n      return callback(error);\n    }\n\n    const originalArgs = _.clone(args);\n    const originalCallback = callback;\n    callback = this.wrapControllerCheckIfNeeded(requestType, originalArgs, originalCallback);\n\n    this.sendRequestToBroker(controllerId, requestType, args, callback);\n  });\n};\n\nKafkaClient.prototype.sendFetchRequest = function (\n  consumer,\n  payloads,\n  fetchMaxWaitMs,\n  fetchMinBytes,\n  maxTickMessages,\n  callback\n) {\n  const memberId = consumer.memberId;\n  const generationId = consumer.generationId;\n\n  if (memberId == null && generationId == null) {\n    Client.prototype.sendFetchRequest.apply(this, arguments);\n    return;\n  }\n\n  payloads = _.cloneDeep(payloads);\n  function stateValidator (unused, type, message) {\n    const payloadMap = consumer.payloadMap;\n    if (\n      consumer.closing ||\n      consumer.connecting ||\n      consumer.rebalancing ||\n      consumer.memberId !== memberId ||\n      consumer.generationId !== generationId\n    ) {\n      logger.error(\n        'ignoring message due to it being from an old group - memberId: ' + memberId,\n        '!=' + consumer.memberId + ' - generationId: ' + generationId + '!=' + consumer.generationId\n      );\n      return false;\n    }\n    if (type === 'message') {\n      const { topic, partition, offset } = message;\n      if (!payloadMap[topic] || payloadMap[topic][partition] == null) {\n        logger.error('received unexpected message', message, payloadMap);\n        // We should have never received this in the first place\n        return false;\n      }\n\n      if (offset == null || offset < payloadMap[topic][partition]) {\n        // Kafka may send an older message than we expect (compressed messages, and other unknown reasons)\n        return false;\n      }\n    }\n\n    return true;\n  }\n  if (callback == null) {\n    callback = _.noop;\n  }\n\n  async.series(\n    [\n      callback => {\n        this.verifyPayloadsHasLeaders(payloads, callback);\n      },\n      callback => {\n        const request = {\n          type: 'fetch',\n          longpolling: true,\n          data: {\n            payloads: payloads,\n            args: [fetchMaxWaitMs, fetchMinBytes],\n            decoderArgs: [this._createMessageHandler(consumer, stateValidator), maxTickMessages]\n          }\n        };\n\n        this.sendRequest(request, callback);\n      }\n    ],\n    callback\n  );\n};\n\nKafkaClient.prototype.sendWhenReady = function (broker, correlationId, request, decode, cb) {\n  const doSend = () => {\n    this.queueCallback(broker.socket, correlationId, [decode, cb]);\n    broker.write(request);\n  };\n  if (!broker.isReady()) {\n    this.waitUntilReady(broker, doSend);\n  } else {\n    doSend();\n  }\n};\n\nKafkaClient.prototype.sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, callback) {\n  async.series(\n    [\n      function (callback) {\n        logger.debug('compressing messages if needed');\n        compress(payloads, callback);\n      },\n      callback => {\n        this.verifyPayloadsHasLeaders(payloads, callback);\n      },\n      callback => {\n        const request = {\n          type: 'produce',\n          data: {\n            payloads: payloads,\n            args: [requireAcks, ackTimeoutMs],\n            requireAcks: requireAcks\n          }\n        };\n        this.sendRequest(request, callback);\n      }\n    ],\n    (err, result) => {\n      if (err) {\n        if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {\n          this.emit('brokersChanged');\n        }\n        callback(err);\n      } else {\n        callback(\n          null,\n          _.chain(result)\n            .last()\n            .reduce((accu, value) => _.merge(accu, value), {})\n            .value()\n        );\n      }\n    }\n  );\n};\n\nKafkaClient.prototype.handleReceivedData = function (socket) {\n  if (socket.saslAuthCorrelationId !== undefined) {\n    if (socket.buffer.length < 4) {\n      // not enough data yet\n      return;\n    }\n\n    const size = socket.buffer.readInt32BE(0);\n    if (socket.buffer.length - 4 < size) {\n      // still not enough data\n      return;\n    }\n\n    const resp = socket.buffer.slice(4, 4 + size);\n    this.invokeResponseCallback(socket, socket.saslAuthCorrelationId, resp);\n    delete socket.saslAuthCorrelationId;\n    socket.buffer.consume(size + 4);\n  } else {\n    return Client.prototype.handleReceivedData.call(this, socket);\n  }\n};\n\nKafkaClient.prototype.describeConfigs = function (payload, callback) {\n  if (!this.ready) {\n    return callback(new Error('Client is not ready (describeConfigs)'));\n  }\n  let err;\n\n  // Broker resource requests must go to the specific node\n  // other requests can go to any node\n  const brokerResourceRequests = [];\n  const nonBrokerResourceRequests = [];\n\n  _.forEach(payload.resources, function (resource) {\n    if (resourceTypeMap[resource.resourceType] === undefined) {\n      err = new Error(`Unexpected resource type ${resource.resourceType} for resource ${resource.resourceName}`);\n      return false;\n    } else {\n      resource.resourceType = resourceTypeMap[resource.resourceType];\n    }\n\n    if (resource.resourceType === resourceTypeMap['broker']) {\n      brokerResourceRequests.push(resource);\n    } else {\n      nonBrokerResourceRequests.push(resource);\n    }\n  });\n\n  if (err) {\n    return callback(err);\n  }\n\n  async.parallelLimit([\n    (cb) => {\n      if (nonBrokerResourceRequests.length > 0) {\n        this.sendRequestToAnyBroker('describeConfigs', [{ resources: nonBrokerResourceRequests, includeSynonyms: payload.includeSynonyms }], cb);\n      } else {\n        cb(null, []);\n      }\n    },\n    ...brokerResourceRequests.map(r => {\n      return (cb) => {\n        this.sendRequestToBroker(r.resourceName, 'describeConfigs', [{ resources: [r], includeSynonyms: payload.includeSynonyms }], cb);\n      };\n    })\n  ], this.options.maxAsyncRequests, (err, result) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, _.flatten(result));\n  });\n};\n\n/**\n * Sends a request to any broker in the cluster\n */\nKafkaClient.prototype.sendRequestToAnyBroker = function (requestType, args, callback) {\n  // For now just select the first broker\n  const brokerId = Object.keys(this.brokerMetadata)[0];\n  this.sendRequestToBroker(brokerId, requestType, args, callback);\n};\n\nmodule.exports = KafkaClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}