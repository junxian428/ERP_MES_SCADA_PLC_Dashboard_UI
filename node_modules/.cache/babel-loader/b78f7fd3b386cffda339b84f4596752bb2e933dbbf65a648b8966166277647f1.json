{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/web.immediate.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nvar util = require('util');\nvar _ = require('lodash');\nvar async = require('async');\nvar retry = require('retry');\nvar EventEmitter = require('events');\nvar errors = require('./errors');\nvar getCodec = require('./codec');\nvar protocol = require('./protocol');\nvar encodeMessageSet = protocol.encodeMessageSet;\nvar Message = protocol.Message;\nvar logger = require('./logging')('kafka-node:BaseClient');\nvar validateKafkaTopics = require('./utils').validateTopicNames;\nconst MAX_INT32 = 2147483647;\n\n/**\n *\n * @constructor\n */\nfunction Client() {\n  throw new TypeError('BaseClient cannot be instantiated directly');\n}\nutil.inherits(Client, EventEmitter);\nClient.prototype.closeBrokers = function (brokers) {\n  _.each(brokers, function (broker) {\n    broker.socket.closing = true;\n    broker.socket.end();\n    setImmediate(function () {\n      broker.socket.destroy();\n      broker.socket.unref();\n    });\n  });\n};\nfunction decodeValue(encoding, value) {\n  if (encoding !== 'buffer' && value != null) {\n    return value.toString(encoding);\n  }\n  return value;\n}\nClient.prototype._createMessageHandler = function (consumer, stateValidator) {\n  return (err, type, message) => {\n    if (stateValidator && !stateValidator(err, type, message)) {\n      return;\n    }\n    if (err) {\n      if (err.message === 'OffsetOutOfRange') {\n        return consumer.emit('offsetOutOfRange', err);\n      } else if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {\n        return this.emit('brokersChanged');\n      }\n      return consumer.emit('error', err);\n    }\n    var encoding = consumer.options.encoding;\n    const keyEncoding = consumer.options.keyEncoding;\n    if (type === 'message') {\n      message.value = decodeValue(encoding, message.value);\n      message.key = decodeValue(keyEncoding || encoding, message.key);\n      consumer.emit('message', message);\n    } else {\n      consumer.emit(type, message);\n    }\n  };\n};\nClient.prototype.sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages) {\n  var encoder = protocol.encodeFetchRequest(fetchMaxWaitMs, fetchMinBytes);\n  // TODO: state validator for HLC for ignoring stale fetch requests\n  var decoder = protocol.decodeFetchResponse(this._createMessageHandler(consumer), maxTickMessages);\n  this.send(payloads, encoder, decoder, function (err) {\n    if (err) {\n      Array.prototype.unshift.call(arguments, 'error');\n      consumer.emit.apply(consumer, arguments);\n    }\n  });\n};\nClient.prototype.sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, cb) {\n  var encoder = protocol.encodeProduceRequest(requireAcks, ackTimeoutMs);\n  var decoder = protocol.decodeProduceResponse;\n  var self = this;\n  decoder.requireAcks = requireAcks;\n  async.each(payloads, buildRequest, function (err) {\n    if (err) return cb(err);\n    self.send(payloads, encoder, decoder, function (err, result) {\n      if (err) {\n        if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {\n          self.emit('brokersChanged');\n        }\n        cb(err);\n      } else {\n        cb(null, result);\n      }\n    });\n  });\n  function buildRequest(payload, cb) {\n    var attributes = payload.attributes;\n    var codec = getCodec(attributes);\n    if (!codec) return cb();\n    var innerSet = encodeMessageSet(payload.messages);\n    codec.encode(innerSet, function (err, message) {\n      if (err) return cb(err);\n      payload.messages = [new Message(0, attributes, '', message)];\n      cb();\n    });\n  }\n};\nClient.prototype.sendOffsetCommitRequest = function (group, payloads, cb) {\n  var encoder = protocol.encodeOffsetCommitRequest(group);\n  var decoder = protocol.decodeOffsetCommitResponse;\n  this.send(payloads, encoder, decoder, cb);\n};\nClient.prototype.sendOffsetCommitV2Request = function (group, generationId, memberId, payloads, cb) {\n  var encoder = protocol.encodeOffsetCommitV2Request;\n  var decoder = protocol.decodeOffsetCommitResponse;\n  this.sendGroupRequest(encoder, decoder, arguments);\n};\nClient.prototype.sendOffsetFetchV1Request = function (group, payloads, cb) {\n  var encoder = protocol.encodeOffsetFetchV1Request;\n  var decoder = protocol.decodeOffsetFetchV1Response;\n  this.sendGroupRequest(encoder, decoder, arguments);\n};\nClient.prototype.setCoordinatorIdAndSendOffsetFetchV1Request = function (group, payloads, cb) {\n  this.sendGroupCoordinatorRequest(group, (err, coordinatorInfo) => {\n    if (err) return cb(new errors.BrokerNotAvailableError('Broker not available'));\n    this.coordinatorId = String(coordinatorInfo.coordinatorId);\n    this.sendOffsetFetchV1Request(group, payloads, cb);\n  });\n};\nClient.prototype.sendOffsetFetchRequest = function (group, payloads, cb) {\n  var encoder = protocol.encodeOffsetFetchRequest(group);\n  var decoder = protocol.decodeOffsetFetchResponse;\n  this.send(payloads, encoder, decoder, cb);\n};\nClient.prototype.sendOffsetRequest = function (payloads, cb) {\n  var encoder = protocol.encodeOffsetRequest;\n  var decoder = protocol.decodeOffsetResponse;\n  this.send(payloads, encoder, decoder, cb);\n};\nClient.prototype.refreshBrokerMetadata = function () {};\nClient.prototype.sendWhenReady = function (broker, correlationId, request, decode, cb) {\n  this.queueCallback(broker.socket, correlationId, [decode, cb]);\n  broker.write(request);\n};\nClient.prototype.sendGroupRequest = function (encode, decode, requestArgs) {\n  requestArgs = _.values(requestArgs);\n  var cb = requestArgs.pop();\n  var correlationId = this.nextId();\n  requestArgs.unshift(this.clientId, correlationId);\n  var request = encode.apply(null, requestArgs);\n  var broker = this.brokerForLeader(this.coordinatorId);\n  var brokerError = null;\n  if (!broker) {\n    brokerError = 'Could not find broker';\n  } else if (!broker.isConnected()) {\n    brokerError = 'Broker socket is closed' + (broker.socket.error ? ' - ' + broker.socket.error.message : '');\n  }\n  if (brokerError) {\n    this.refreshBrokerMetadata();\n    return cb(new errors.BrokerNotAvailableError('Broker not available: ' + brokerError));\n  }\n  this.sendWhenReady(broker, correlationId, request, decode, cb);\n};\nClient.prototype.sendGroupCoordinatorRequest = function (groupId, cb) {\n  this.sendGroupRequest(protocol.encodeGroupCoordinatorRequest, protocol.decodeGroupCoordinatorResponse, arguments);\n};\nClient.prototype.sendJoinGroupRequest = function (groupId, memberId, sessionTimeout, groupProtocol, cb) {\n  this.sendGroupRequest(protocol.encodeJoinGroupRequest, protocol.decodeJoinGroupResponse, arguments);\n};\nClient.prototype.sendSyncGroupRequest = function (groupId, generationId, memberId, groupAssignment, cb) {\n  this.sendGroupRequest(protocol.encodeSyncGroupRequest, protocol.decodeSyncGroupResponse, arguments);\n};\nClient.prototype.sendHeartbeatRequest = function (groupId, generationId, memberId, cb) {\n  this.sendGroupRequest(protocol.encodeGroupHeartbeatRequest, protocol.decodeGroupHeartbeatResponse, arguments);\n};\nClient.prototype.sendLeaveGroupRequest = function (groupId, memberId, cb) {\n  this.sendGroupRequest(protocol.encodeLeaveGroupRequest, protocol.decodeLeaveGroupResponse, arguments);\n};\n\n/*\n *  Helper method\n *  topic in payloads may send to different broker, so we cache data util all request came back\n */\nfunction wrap(payloads, cb) {\n  var out = {};\n  var count = Object.keys(payloads).length;\n  return function (err, data) {\n    // data: { topicName1: {}, topicName2: {} }\n    if (err) return cb && cb(err);\n    _.merge(out, data);\n    count -= 1;\n    // Waiting for all request return\n    if (count !== 0) return;\n    cb && cb(null, out);\n  };\n}\n\n/**\n * Fetches metadata information for a topic\n * This includes an array containing a each zookeeper node, their nodeId, host name, and port. As well as an object\n * containing the topic name, partition, leader number, replica count, and in sync replicas per partition.\n *\n * @param {Array} topics An array of topics to load the metadata for\n * @param {Client~loadMetadataForTopicsCallback} cb Function to call once all metadata is loaded\n */\nClient.prototype.loadMetadataForTopics = function (topics, cb) {\n  var correlationId = this.nextId();\n  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, topics);\n  var broker = this.brokerForLeader();\n  if (!broker || !broker.isConnected()) {\n    return cb(new errors.BrokerNotAvailableError('Broker not available'));\n  }\n  this.sendWhenReady(broker, correlationId, request, protocol.decodeMetadataResponse, cb);\n};\nClient.prototype.createTopics = function (topics, isAsync, cb) {\n  topics = typeof topics === 'string' ? [topics] : topics;\n  if (typeof isAsync === 'function' && typeof cb === 'undefined') {\n    cb = isAsync;\n    isAsync = true;\n  }\n  try {\n    validateKafkaTopics(topics);\n  } catch (e) {\n    if (isAsync) return cb(e);\n    throw e;\n  }\n  cb = _.once(cb);\n  const getTopicsFromKafka = (topics, callback) => {\n    this.loadMetadataForTopics(topics, function (error, resp) {\n      if (error) {\n        return callback(error);\n      }\n      callback(null, Object.keys(resp[1].metadata));\n    });\n  };\n  const operation = retry.operation({\n    minTimeout: 200,\n    maxTimeout: 2000\n  });\n  operation.attempt(currentAttempt => {\n    logger.debug('create topics currentAttempt', currentAttempt);\n    getTopicsFromKafka(topics, function (error, kafkaTopics) {\n      if (error) {\n        if (operation.retry(error)) {\n          return;\n        }\n      }\n      logger.debug('kafka reported topics', kafkaTopics);\n      const left = _.difference(topics, kafkaTopics);\n      if (left.length === 0) {\n        logger.debug(`Topics created ${kafkaTopics}`);\n        return cb(null, kafkaTopics);\n      }\n      logger.debug(`Topics left ${left.join(', ')}`);\n      if (!operation.retry(new Error(`Topics not created ${left}`))) {\n        cb(operation.mainError());\n      }\n    });\n  });\n  if (!isAsync) {\n    cb(null);\n  }\n};\nClient.prototype.addTopics = function (topics, cb) {\n  var self = this;\n  this.topicExists(topics, function (err) {\n    if (err) return cb(err);\n    self.loadMetadataForTopics(topics, function (err, resp) {\n      if (err) return cb(err);\n      self.updateMetadatas(resp);\n      cb(null, topics);\n    });\n  });\n};\nClient.prototype.nextId = function () {\n  if (this.correlationId >= MAX_INT32) {\n    this.correlationId = 0;\n  }\n  return this.correlationId++;\n};\nClient.prototype.nextSocketId = function () {\n  return this._socketId++;\n};\nClient.prototype.refreshBrokers = function () {\n  var self = this;\n  var validBrokers = Object.keys(this.brokerProfiles);\n  function closeDeadBrokers(brokers) {\n    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);\n    if (deadBrokerKeys.length) {\n      self.closeBrokers(deadBrokerKeys.map(function (key) {\n        var broker = brokers[key];\n        delete brokers[key];\n        return broker;\n      }));\n    }\n  }\n  closeDeadBrokers(this.brokers);\n  closeDeadBrokers(this.longpollingBrokers);\n};\nClient.prototype.refreshMetadata = function (topicNames, cb) {\n  var self = this;\n  if (!topicNames.length) return cb();\n  attemptRequestMetadata(topicNames, cb);\n  function attemptRequestMetadata(topics, cb) {\n    var operation = retry.operation({\n      minTimeout: 200,\n      maxTimeout: 1000\n    });\n    operation.attempt(function (currentAttempt) {\n      logger.debug('refresh metadata currentAttempt', currentAttempt);\n      self.loadMetadataForTopics(topics, function (err, resp) {\n        err = err || resp[1].error;\n        if (Array.isArray(err)) {\n          err = new Error(String(err));\n        }\n        if (operation.retry(err)) {\n          return;\n        }\n        if (err) {\n          logger.debug('refresh metadata error', err.message);\n          return cb(err);\n        }\n        self.updateMetadatas(resp);\n        cb();\n      });\n    });\n  }\n};\nClient.prototype.send = function (payloads, encoder, decoder, cb) {\n  var self = this;\n  var _payloads = payloads;\n  // payloads: [ [metadata exists], [metadata not exists] ]\n  payloads = this.checkMetadatas(payloads);\n  if (payloads[0].length && !payloads[1].length) {\n    this.sendToBroker(_.flatten(payloads), encoder, decoder, cb);\n    return;\n  }\n  if (payloads[1].length) {\n    var topicNames = payloads[1].map(function (p) {\n      return p.topic;\n    });\n    this.loadMetadataForTopics(topicNames, function (err, resp) {\n      if (err) {\n        return cb(err);\n      }\n      var error = resp[1].error;\n      if (error) {\n        return cb(error);\n      }\n      self.updateMetadatas(resp);\n      // check payloads again\n      payloads = self.checkMetadatas(_payloads);\n      if (payloads[1].length) {\n        self.refreshBrokerMetadata();\n        return cb(new errors.BrokerNotAvailableError('Could not find the leader'));\n      }\n      self.sendToBroker(payloads[1].concat(payloads[0]), encoder, decoder, cb);\n    });\n  }\n};\nClient.prototype.sendToBroker = function (payloads, encoder, decoder, cb) {\n  var longpolling = encoder.name === 'encodeFetchRequest';\n  payloads = this.payloadsByLeader(payloads);\n  if (!longpolling) {\n    cb = wrap(payloads, cb);\n  }\n  for (var leader in payloads) {\n    if (!payloads.hasOwnProperty(leader)) {\n      continue;\n    }\n    var correlationId = this.nextId();\n    var broker = this.brokerForLeader(leader, longpolling);\n    var brokerError = null;\n    if (!broker) {\n      brokerError = 'Could not find broker';\n    } else if (!broker.isConnected()) {\n      brokerError = 'Broker socket is closed' + (broker.socket.error ? ' - ' + broker.socket.error.message : '');\n    }\n    if (brokerError) {\n      this.refreshBrokerMetadata();\n      return cb(new errors.BrokerNotAvailableError('Broker not available: ' + brokerError), payloads[leader]);\n    }\n    if (longpolling) {\n      if (broker.socket.waiting) {\n        continue;\n      }\n      broker.socket.waiting = true;\n    }\n    var request = encoder(this.clientId, correlationId, payloads[leader]);\n    if (decoder.requireAcks === 0) {\n      broker.writeAsync(request);\n      cb(null, {\n        result: 'no ack'\n      });\n    } else {\n      this.sendWhenReady(broker, correlationId, request, decoder, cb);\n    }\n  }\n};\nClient.prototype.checkMetadatas = function (payloads) {\n  if (_.isEmpty(this.topicMetadata)) return [[], payloads];\n  // out: [ [metadata exists], [metadata not exists] ]\n  var out = [[], []];\n  payloads.forEach(function (p) {\n    if (this.hasMetadata(p.topic, p.partition)) out[0].push(p);else out[1].push(p);\n  }.bind(this));\n  return out;\n};\nClient.prototype.hasMetadata = function (topic, partition) {\n  var brokerMetadata = this.brokerMetadata;\n  var leader = this.leaderByPartition(topic, partition);\n  return leader !== undefined && brokerMetadata[leader];\n};\nClient.prototype.updateMetadatas = function (metadatas) {\n  // _.extend(this.brokerMetadata, metadatas[0])\n  _.extend(this.topicMetadata, metadatas[1].metadata);\n  for (var topic in this.topicMetadata) {\n    if (!this.topicMetadata.hasOwnProperty(topic)) {\n      continue;\n    }\n    this.topicPartitions[topic] = Object.keys(this.topicMetadata[topic]).map(function (val) {\n      return parseInt(val, 10);\n    });\n  }\n};\nClient.prototype.removeTopicMetadata = function (topics, cb) {\n  topics.forEach(function (t) {\n    if (this.topicMetadata[t]) delete this.topicMetadata[t];\n  }.bind(this));\n  cb(null, topics.length);\n};\nClient.prototype.payloadsByLeader = function (payloads) {\n  return payloads.reduce(function (out, p) {\n    var leader = this.leaderByPartition(p.topic, p.partition);\n    out[leader] = out[leader] || [];\n    out[leader].push(p);\n    return out;\n  }.bind(this), {});\n};\nClient.prototype.leaderByPartition = function (topic, partition) {\n  var topicMetadata = this.topicMetadata;\n  return topicMetadata[topic] && topicMetadata[topic][partition] && topicMetadata[topic][partition].leader;\n};\nClient.prototype.brokerForLeader = function (leader, longpolling) {\n  var addr;\n  var brokers = this.getBrokers(longpolling);\n  // If leader is not give, choose the first broker as leader\n  if (typeof leader === 'undefined') {\n    if (!_.isEmpty(brokers)) {\n      addr = Object.keys(brokers)[0];\n      return brokers[addr];\n    } else if (!_.isEmpty(this.brokerMetadata)) {\n      leader = Object.keys(this.brokerMetadata)[0];\n    } else {\n      return;\n    }\n  }\n  var broker = _.find(this.brokerProfiles, {\n    id: leader\n  });\n  if (!broker) {\n    return;\n  }\n  addr = broker.host + ':' + broker.port;\n  return brokers[addr] || this.setupBroker(broker.host, broker.port, longpolling, brokers);\n};\nClient.prototype.getBrokers = function (longpolling) {\n  return longpolling ? this.longpollingBrokers : this.brokers;\n};\nClient.prototype.reconnectBroker = function (oldSocket) {\n  oldSocket.retrying = false;\n  if (oldSocket.error) {\n    oldSocket.destroy();\n  }\n  var brokers = this.getBrokers(oldSocket.longpolling);\n  var newBroker = this.setupBroker(oldSocket.host, oldSocket.port, oldSocket.longpolling, brokers);\n  newBroker.socket.error = oldSocket.error;\n};\nClient.prototype.handleReceivedData = function (socket) {\n  var buffer = socket.buffer;\n  if (!buffer.length || buffer.length < 4) {\n    return;\n  }\n  var size = buffer.readUInt32BE(0) + 4;\n  if (buffer.length >= size) {\n    if (socket.longpolling) {\n      socket.waiting = false;\n    }\n    var resp = buffer.shallowSlice(0, size);\n    var correlationId = resp.readUInt32BE(4);\n    this.invokeResponseCallback(socket, correlationId, resp);\n    buffer.consume(size);\n  } else {\n    return;\n  }\n  if (socket.buffer.length) {\n    setImmediate(function () {\n      this.handleReceivedData(socket);\n    }.bind(this));\n  }\n};\nClient.prototype.invokeResponseCallback = function (socket, correlationId, resp) {\n  var handlers = this.unqueueCallback(socket, correlationId);\n  if (handlers) {\n    var [decoder, cb] = handlers;\n    var result = decoder(resp);\n    if (result instanceof Error) {\n      cb.call(this, result);\n    } else {\n      cb.call(this, null, result);\n    }\n  } else {\n    logger.error(`missing handlers for Correlation ID: ${correlationId}`);\n  }\n};\nClient.prototype.queueCallback = function (socket, id, data) {\n  var socketId = socket.socketId;\n  var queue = this.cbqueue.get(socketId);\n  if (!queue) {\n    queue = new Map();\n    this.cbqueue.set(socketId, queue);\n  }\n  queue.set(id, data);\n};\nClient.prototype.unqueueCallback = function (socket, id) {\n  var socketId = socket.socketId;\n  var queue = this.cbqueue.get(socketId);\n  try {\n    if (!queue) {\n      return null;\n    }\n    if (!queue.has(id)) {\n      return null;\n    }\n    var result = queue.get(id);\n\n    // cleanup socket queue\n    queue.delete(id);\n    return result;\n  } finally {\n    if (queue && !queue.size) {\n      this.cbqueue.delete(socketId);\n    }\n  }\n};\nClient.prototype.clearCallbackQueue = function (socket, error) {\n  var socketId = socket.socketId;\n  var longpolling = socket.longpolling;\n  var queue = this.cbqueue.get(socketId);\n  if (!queue) {\n    return;\n  }\n  if (!longpolling) {\n    queue.forEach(function (handlers) {\n      var cb = handlers[1];\n      cb(error);\n    });\n  }\n  this.cbqueue.delete(socketId);\n};\nmodule.exports = Client;","map":{"version":3,"names":["require","util","_","async","retry","EventEmitter","errors","getCodec","protocol","encodeMessageSet","Message","logger","validateKafkaTopics","validateTopicNames","MAX_INT32","Client","TypeError","inherits","prototype","closeBrokers","brokers","each","broker","socket","closing","end","setImmediate","destroy","unref","decodeValue","encoding","value","toString","_createMessageHandler","consumer","stateValidator","err","type","message","emit","options","keyEncoding","key","sendFetchRequest","payloads","fetchMaxWaitMs","fetchMinBytes","maxTickMessages","encoder","encodeFetchRequest","decoder","decodeFetchResponse","send","Array","unshift","call","arguments","apply","sendProduceRequest","requireAcks","ackTimeoutMs","cb","encodeProduceRequest","decodeProduceResponse","self","buildRequest","result","payload","attributes","codec","innerSet","messages","encode","sendOffsetCommitRequest","group","encodeOffsetCommitRequest","decodeOffsetCommitResponse","sendOffsetCommitV2Request","generationId","memberId","encodeOffsetCommitV2Request","sendGroupRequest","sendOffsetFetchV1Request","encodeOffsetFetchV1Request","decodeOffsetFetchV1Response","setCoordinatorIdAndSendOffsetFetchV1Request","sendGroupCoordinatorRequest","coordinatorInfo","BrokerNotAvailableError","coordinatorId","String","sendOffsetFetchRequest","encodeOffsetFetchRequest","decodeOffsetFetchResponse","sendOffsetRequest","encodeOffsetRequest","decodeOffsetResponse","refreshBrokerMetadata","sendWhenReady","correlationId","request","decode","queueCallback","write","requestArgs","values","pop","nextId","clientId","brokerForLeader","brokerError","isConnected","error","groupId","encodeGroupCoordinatorRequest","decodeGroupCoordinatorResponse","sendJoinGroupRequest","sessionTimeout","groupProtocol","encodeJoinGroupRequest","decodeJoinGroupResponse","sendSyncGroupRequest","groupAssignment","encodeSyncGroupRequest","decodeSyncGroupResponse","sendHeartbeatRequest","encodeGroupHeartbeatRequest","decodeGroupHeartbeatResponse","sendLeaveGroupRequest","encodeLeaveGroupRequest","decodeLeaveGroupResponse","wrap","out","count","Object","keys","length","data","merge","loadMetadataForTopics","topics","encodeMetadataRequest","decodeMetadataResponse","createTopics","isAsync","e","once","getTopicsFromKafka","callback","resp","metadata","operation","minTimeout","maxTimeout","attempt","currentAttempt","debug","kafkaTopics","left","difference","join","Error","mainError","addTopics","topicExists","updateMetadatas","nextSocketId","_socketId","refreshBrokers","validBrokers","brokerProfiles","closeDeadBrokers","deadBrokerKeys","map","longpollingBrokers","refreshMetadata","topicNames","attemptRequestMetadata","isArray","_payloads","checkMetadatas","sendToBroker","flatten","p","topic","concat","longpolling","name","payloadsByLeader","leader","hasOwnProperty","waiting","writeAsync","isEmpty","topicMetadata","forEach","hasMetadata","partition","push","bind","brokerMetadata","leaderByPartition","undefined","metadatas","extend","topicPartitions","val","parseInt","removeTopicMetadata","t","reduce","addr","getBrokers","find","id","host","port","setupBroker","reconnectBroker","oldSocket","retrying","newBroker","handleReceivedData","buffer","size","readUInt32BE","shallowSlice","invokeResponseCallback","consume","handlers","unqueueCallback","socketId","queue","cbqueue","get","Map","set","has","delete","clearCallbackQueue","module","exports"],"sources":["D:/Project/VUEJSSPRING_CRUD_JWT/vue-crud-api-jwt-vuex/node_modules/kafka-node/lib/baseClient.js"],"sourcesContent":["'use strict';\n\nvar util = require('util');\nvar _ = require('lodash');\nvar async = require('async');\nvar retry = require('retry');\nvar EventEmitter = require('events');\nvar errors = require('./errors');\nvar getCodec = require('./codec');\nvar protocol = require('./protocol');\nvar encodeMessageSet = protocol.encodeMessageSet;\nvar Message = protocol.Message;\nvar logger = require('./logging')('kafka-node:BaseClient');\nvar validateKafkaTopics = require('./utils').validateTopicNames;\n\nconst MAX_INT32 = 2147483647;\n\n/**\n *\n * @constructor\n */\nfunction Client () {\n  throw new TypeError('BaseClient cannot be instantiated directly');\n}\n\nutil.inherits(Client, EventEmitter);\n\nClient.prototype.closeBrokers = function (brokers) {\n  _.each(brokers, function (broker) {\n    broker.socket.closing = true;\n    broker.socket.end();\n    setImmediate(function () {\n      broker.socket.destroy();\n      broker.socket.unref();\n    });\n  });\n};\n\nfunction decodeValue (encoding, value) {\n  if (encoding !== 'buffer' && value != null) {\n    return value.toString(encoding);\n  }\n  return value;\n}\n\nClient.prototype._createMessageHandler = function (consumer, stateValidator) {\n  return (err, type, message) => {\n    if (stateValidator && !stateValidator(err, type, message)) {\n      return;\n    }\n    if (err) {\n      if (err.message === 'OffsetOutOfRange') {\n        return consumer.emit('offsetOutOfRange', err);\n      } else if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {\n        return this.emit('brokersChanged');\n      }\n\n      return consumer.emit('error', err);\n    }\n\n    var encoding = consumer.options.encoding;\n    const keyEncoding = consumer.options.keyEncoding;\n\n    if (type === 'message') {\n      message.value = decodeValue(encoding, message.value);\n      message.key = decodeValue(keyEncoding || encoding, message.key);\n\n      consumer.emit('message', message);\n    } else {\n      consumer.emit(type, message);\n    }\n  };\n};\n\nClient.prototype.sendFetchRequest = function (consumer, payloads, fetchMaxWaitMs, fetchMinBytes, maxTickMessages) {\n  var encoder = protocol.encodeFetchRequest(fetchMaxWaitMs, fetchMinBytes);\n  // TODO: state validator for HLC for ignoring stale fetch requests\n  var decoder = protocol.decodeFetchResponse(this._createMessageHandler(consumer), maxTickMessages);\n\n  this.send(payloads, encoder, decoder, function (err) {\n    if (err) {\n      Array.prototype.unshift.call(arguments, 'error');\n      consumer.emit.apply(consumer, arguments);\n    }\n  });\n};\n\nClient.prototype.sendProduceRequest = function (payloads, requireAcks, ackTimeoutMs, cb) {\n  var encoder = protocol.encodeProduceRequest(requireAcks, ackTimeoutMs);\n  var decoder = protocol.decodeProduceResponse;\n  var self = this;\n\n  decoder.requireAcks = requireAcks;\n\n  async.each(payloads, buildRequest, function (err) {\n    if (err) return cb(err);\n    self.send(payloads, encoder, decoder, function (err, result) {\n      if (err) {\n        if (err.message === 'NotLeaderForPartition' || err.message === 'UnknownTopicOrPartition') {\n          self.emit('brokersChanged');\n        }\n        cb(err);\n      } else {\n        cb(null, result);\n      }\n    });\n  });\n\n  function buildRequest (payload, cb) {\n    var attributes = payload.attributes;\n    var codec = getCodec(attributes);\n\n    if (!codec) return cb();\n\n    var innerSet = encodeMessageSet(payload.messages);\n    codec.encode(innerSet, function (err, message) {\n      if (err) return cb(err);\n      payload.messages = [new Message(0, attributes, '', message)];\n      cb();\n    });\n  }\n};\n\nClient.prototype.sendOffsetCommitRequest = function (group, payloads, cb) {\n  var encoder = protocol.encodeOffsetCommitRequest(group);\n  var decoder = protocol.decodeOffsetCommitResponse;\n  this.send(payloads, encoder, decoder, cb);\n};\n\nClient.prototype.sendOffsetCommitV2Request = function (group, generationId, memberId, payloads, cb) {\n  var encoder = protocol.encodeOffsetCommitV2Request;\n  var decoder = protocol.decodeOffsetCommitResponse;\n  this.sendGroupRequest(encoder, decoder, arguments);\n};\n\nClient.prototype.sendOffsetFetchV1Request = function (group, payloads, cb) {\n  var encoder = protocol.encodeOffsetFetchV1Request;\n  var decoder = protocol.decodeOffsetFetchV1Response;\n  this.sendGroupRequest(encoder, decoder, arguments);\n};\n\nClient.prototype.setCoordinatorIdAndSendOffsetFetchV1Request = function (group, payloads, cb) {\n  this.sendGroupCoordinatorRequest(group, (err, coordinatorInfo) => {\n    if (err) return cb(new errors.BrokerNotAvailableError('Broker not available'));\n    this.coordinatorId = String(coordinatorInfo.coordinatorId);\n    this.sendOffsetFetchV1Request(group, payloads, cb);\n  });\n};\n\nClient.prototype.sendOffsetFetchRequest = function (group, payloads, cb) {\n  var encoder = protocol.encodeOffsetFetchRequest(group);\n  var decoder = protocol.decodeOffsetFetchResponse;\n  this.send(payloads, encoder, decoder, cb);\n};\n\nClient.prototype.sendOffsetRequest = function (payloads, cb) {\n  var encoder = protocol.encodeOffsetRequest;\n  var decoder = protocol.decodeOffsetResponse;\n  this.send(payloads, encoder, decoder, cb);\n};\n\nClient.prototype.refreshBrokerMetadata = function () {};\n\nClient.prototype.sendWhenReady = function (broker, correlationId, request, decode, cb) {\n  this.queueCallback(broker.socket, correlationId, [decode, cb]);\n  broker.write(request);\n};\n\nClient.prototype.sendGroupRequest = function (encode, decode, requestArgs) {\n  requestArgs = _.values(requestArgs);\n  var cb = requestArgs.pop();\n  var correlationId = this.nextId();\n\n  requestArgs.unshift(this.clientId, correlationId);\n\n  var request = encode.apply(null, requestArgs);\n  var broker = this.brokerForLeader(this.coordinatorId);\n  var brokerError = null;\n  if (!broker) {\n    brokerError = 'Could not find broker';\n  } else if (!broker.isConnected()) {\n    brokerError = 'Broker socket is closed' + (broker.socket.error ? ' - ' + broker.socket.error.message : '');\n  }\n  if (brokerError) {\n    this.refreshBrokerMetadata();\n    return cb(new errors.BrokerNotAvailableError('Broker not available: ' + brokerError));\n  }\n\n  this.sendWhenReady(broker, correlationId, request, decode, cb);\n};\n\nClient.prototype.sendGroupCoordinatorRequest = function (groupId, cb) {\n  this.sendGroupRequest(protocol.encodeGroupCoordinatorRequest, protocol.decodeGroupCoordinatorResponse, arguments);\n};\n\nClient.prototype.sendJoinGroupRequest = function (groupId, memberId, sessionTimeout, groupProtocol, cb) {\n  this.sendGroupRequest(protocol.encodeJoinGroupRequest, protocol.decodeJoinGroupResponse, arguments);\n};\n\nClient.prototype.sendSyncGroupRequest = function (groupId, generationId, memberId, groupAssignment, cb) {\n  this.sendGroupRequest(protocol.encodeSyncGroupRequest, protocol.decodeSyncGroupResponse, arguments);\n};\n\nClient.prototype.sendHeartbeatRequest = function (groupId, generationId, memberId, cb) {\n  this.sendGroupRequest(protocol.encodeGroupHeartbeatRequest, protocol.decodeGroupHeartbeatResponse, arguments);\n};\n\nClient.prototype.sendLeaveGroupRequest = function (groupId, memberId, cb) {\n  this.sendGroupRequest(protocol.encodeLeaveGroupRequest, protocol.decodeLeaveGroupResponse, arguments);\n};\n\n/*\n *  Helper method\n *  topic in payloads may send to different broker, so we cache data util all request came back\n */\nfunction wrap (payloads, cb) {\n  var out = {};\n  var count = Object.keys(payloads).length;\n\n  return function (err, data) {\n    // data: { topicName1: {}, topicName2: {} }\n    if (err) return cb && cb(err);\n    _.merge(out, data);\n    count -= 1;\n    // Waiting for all request return\n    if (count !== 0) return;\n    cb && cb(null, out);\n  };\n}\n\n/**\n * Fetches metadata information for a topic\n * This includes an array containing a each zookeeper node, their nodeId, host name, and port. As well as an object\n * containing the topic name, partition, leader number, replica count, and in sync replicas per partition.\n *\n * @param {Array} topics An array of topics to load the metadata for\n * @param {Client~loadMetadataForTopicsCallback} cb Function to call once all metadata is loaded\n */\nClient.prototype.loadMetadataForTopics = function (topics, cb) {\n  var correlationId = this.nextId();\n  var request = protocol.encodeMetadataRequest(this.clientId, correlationId, topics);\n  var broker = this.brokerForLeader();\n\n  if (!broker || !broker.isConnected()) {\n    return cb(new errors.BrokerNotAvailableError('Broker not available'));\n  }\n\n  this.sendWhenReady(broker, correlationId, request, protocol.decodeMetadataResponse, cb);\n};\n\nClient.prototype.createTopics = function (topics, isAsync, cb) {\n  topics = typeof topics === 'string' ? [topics] : topics;\n\n  if (typeof isAsync === 'function' && typeof cb === 'undefined') {\n    cb = isAsync;\n    isAsync = true;\n  }\n\n  try {\n    validateKafkaTopics(topics);\n  } catch (e) {\n    if (isAsync) return cb(e);\n    throw e;\n  }\n\n  cb = _.once(cb);\n\n  const getTopicsFromKafka = (topics, callback) => {\n    this.loadMetadataForTopics(topics, function (error, resp) {\n      if (error) {\n        return callback(error);\n      }\n      callback(null, Object.keys(resp[1].metadata));\n    });\n  };\n\n  const operation = retry.operation({ minTimeout: 200, maxTimeout: 2000 });\n\n  operation.attempt(currentAttempt => {\n    logger.debug('create topics currentAttempt', currentAttempt);\n    getTopicsFromKafka(topics, function (error, kafkaTopics) {\n      if (error) {\n        if (operation.retry(error)) {\n          return;\n        }\n      }\n\n      logger.debug('kafka reported topics', kafkaTopics);\n      const left = _.difference(topics, kafkaTopics);\n      if (left.length === 0) {\n        logger.debug(`Topics created ${kafkaTopics}`);\n        return cb(null, kafkaTopics);\n      }\n\n      logger.debug(`Topics left ${left.join(', ')}`);\n      if (!operation.retry(new Error(`Topics not created ${left}`))) {\n        cb(operation.mainError());\n      }\n    });\n  });\n\n  if (!isAsync) {\n    cb(null);\n  }\n};\n\nClient.prototype.addTopics = function (topics, cb) {\n  var self = this;\n  this.topicExists(topics, function (err) {\n    if (err) return cb(err);\n    self.loadMetadataForTopics(topics, function (err, resp) {\n      if (err) return cb(err);\n      self.updateMetadatas(resp);\n      cb(null, topics);\n    });\n  });\n};\n\nClient.prototype.nextId = function () {\n  if (this.correlationId >= MAX_INT32) {\n    this.correlationId = 0;\n  }\n  return this.correlationId++;\n};\n\nClient.prototype.nextSocketId = function () {\n  return this._socketId++;\n};\n\nClient.prototype.refreshBrokers = function () {\n  var self = this;\n  var validBrokers = Object.keys(this.brokerProfiles);\n\n  function closeDeadBrokers (brokers) {\n    var deadBrokerKeys = _.difference(Object.keys(brokers), validBrokers);\n    if (deadBrokerKeys.length) {\n      self.closeBrokers(\n        deadBrokerKeys.map(function (key) {\n          var broker = brokers[key];\n          delete brokers[key];\n          return broker;\n        })\n      );\n    }\n  }\n\n  closeDeadBrokers(this.brokers);\n  closeDeadBrokers(this.longpollingBrokers);\n};\n\nClient.prototype.refreshMetadata = function (topicNames, cb) {\n  var self = this;\n  if (!topicNames.length) return cb();\n  attemptRequestMetadata(topicNames, cb);\n\n  function attemptRequestMetadata (topics, cb) {\n    var operation = retry.operation({ minTimeout: 200, maxTimeout: 1000 });\n    operation.attempt(function (currentAttempt) {\n      logger.debug('refresh metadata currentAttempt', currentAttempt);\n      self.loadMetadataForTopics(topics, function (err, resp) {\n        err = err || resp[1].error;\n        if (Array.isArray(err)) {\n          err = new Error(String(err));\n        }\n        if (operation.retry(err)) {\n          return;\n        }\n        if (err) {\n          logger.debug('refresh metadata error', err.message);\n          return cb(err);\n        }\n        self.updateMetadatas(resp);\n        cb();\n      });\n    });\n  }\n};\n\nClient.prototype.send = function (payloads, encoder, decoder, cb) {\n  var self = this;\n  var _payloads = payloads;\n  // payloads: [ [metadata exists], [metadata not exists] ]\n  payloads = this.checkMetadatas(payloads);\n  if (payloads[0].length && !payloads[1].length) {\n    this.sendToBroker(_.flatten(payloads), encoder, decoder, cb);\n    return;\n  }\n  if (payloads[1].length) {\n    var topicNames = payloads[1].map(function (p) {\n      return p.topic;\n    });\n    this.loadMetadataForTopics(topicNames, function (err, resp) {\n      if (err) {\n        return cb(err);\n      }\n\n      var error = resp[1].error;\n      if (error) {\n        return cb(error);\n      }\n\n      self.updateMetadatas(resp);\n      // check payloads again\n      payloads = self.checkMetadatas(_payloads);\n      if (payloads[1].length) {\n        self.refreshBrokerMetadata();\n        return cb(new errors.BrokerNotAvailableError('Could not find the leader'));\n      }\n\n      self.sendToBroker(payloads[1].concat(payloads[0]), encoder, decoder, cb);\n    });\n  }\n};\n\nClient.prototype.sendToBroker = function (payloads, encoder, decoder, cb) {\n  var longpolling = encoder.name === 'encodeFetchRequest';\n  payloads = this.payloadsByLeader(payloads);\n  if (!longpolling) {\n    cb = wrap(payloads, cb);\n  }\n  for (var leader in payloads) {\n    if (!payloads.hasOwnProperty(leader)) {\n      continue;\n    }\n    var correlationId = this.nextId();\n    var broker = this.brokerForLeader(leader, longpolling);\n    var brokerError = null;\n    if (!broker) {\n      brokerError = 'Could not find broker';\n    } else if (!broker.isConnected()) {\n      brokerError = 'Broker socket is closed' + (broker.socket.error ? ' - ' + broker.socket.error.message : '');\n    }\n    if (brokerError) {\n      this.refreshBrokerMetadata();\n      return cb(new errors.BrokerNotAvailableError('Broker not available: ' + brokerError), payloads[leader]);\n    }\n\n    if (longpolling) {\n      if (broker.socket.waiting) {\n        continue;\n      }\n      broker.socket.waiting = true;\n    }\n    var request = encoder(this.clientId, correlationId, payloads[leader]);\n\n    if (decoder.requireAcks === 0) {\n      broker.writeAsync(request);\n      cb(null, { result: 'no ack' });\n    } else {\n      this.sendWhenReady(broker, correlationId, request, decoder, cb);\n    }\n  }\n};\n\nClient.prototype.checkMetadatas = function (payloads) {\n  if (_.isEmpty(this.topicMetadata)) return [[], payloads];\n  // out: [ [metadata exists], [metadata not exists] ]\n  var out = [[], []];\n  payloads.forEach(\n    function (p) {\n      if (this.hasMetadata(p.topic, p.partition)) out[0].push(p);\n      else out[1].push(p);\n    }.bind(this)\n  );\n  return out;\n};\n\nClient.prototype.hasMetadata = function (topic, partition) {\n  var brokerMetadata = this.brokerMetadata;\n  var leader = this.leaderByPartition(topic, partition);\n\n  return leader !== undefined && brokerMetadata[leader];\n};\n\nClient.prototype.updateMetadatas = function (metadatas) {\n  // _.extend(this.brokerMetadata, metadatas[0])\n  _.extend(this.topicMetadata, metadatas[1].metadata);\n  for (var topic in this.topicMetadata) {\n    if (!this.topicMetadata.hasOwnProperty(topic)) {\n      continue;\n    }\n    this.topicPartitions[topic] = Object.keys(this.topicMetadata[topic]).map(function (val) {\n      return parseInt(val, 10);\n    });\n  }\n};\n\nClient.prototype.removeTopicMetadata = function (topics, cb) {\n  topics.forEach(\n    function (t) {\n      if (this.topicMetadata[t]) delete this.topicMetadata[t];\n    }.bind(this)\n  );\n  cb(null, topics.length);\n};\n\nClient.prototype.payloadsByLeader = function (payloads) {\n  return payloads.reduce(\n    function (out, p) {\n      var leader = this.leaderByPartition(p.topic, p.partition);\n      out[leader] = out[leader] || [];\n      out[leader].push(p);\n      return out;\n    }.bind(this),\n    {}\n  );\n};\n\nClient.prototype.leaderByPartition = function (topic, partition) {\n  var topicMetadata = this.topicMetadata;\n  return topicMetadata[topic] && topicMetadata[topic][partition] && topicMetadata[topic][partition].leader;\n};\n\nClient.prototype.brokerForLeader = function (leader, longpolling) {\n  var addr;\n  var brokers = this.getBrokers(longpolling);\n  // If leader is not give, choose the first broker as leader\n  if (typeof leader === 'undefined') {\n    if (!_.isEmpty(brokers)) {\n      addr = Object.keys(brokers)[0];\n      return brokers[addr];\n    } else if (!_.isEmpty(this.brokerMetadata)) {\n      leader = Object.keys(this.brokerMetadata)[0];\n    } else {\n      return;\n    }\n  }\n\n  var broker = _.find(this.brokerProfiles, { id: leader });\n\n  if (!broker) {\n    return;\n  }\n\n  addr = broker.host + ':' + broker.port;\n\n  return brokers[addr] || this.setupBroker(broker.host, broker.port, longpolling, brokers);\n};\n\nClient.prototype.getBrokers = function (longpolling) {\n  return longpolling ? this.longpollingBrokers : this.brokers;\n};\n\nClient.prototype.reconnectBroker = function (oldSocket) {\n  oldSocket.retrying = false;\n  if (oldSocket.error) {\n    oldSocket.destroy();\n  }\n  var brokers = this.getBrokers(oldSocket.longpolling);\n  var newBroker = this.setupBroker(oldSocket.host, oldSocket.port, oldSocket.longpolling, brokers);\n  newBroker.socket.error = oldSocket.error;\n};\n\nClient.prototype.handleReceivedData = function (socket) {\n  var buffer = socket.buffer;\n  if (!buffer.length || buffer.length < 4) {\n    return;\n  }\n  var size = buffer.readUInt32BE(0) + 4;\n\n  if (buffer.length >= size) {\n    if (socket.longpolling) {\n      socket.waiting = false;\n    }\n\n    var resp = buffer.shallowSlice(0, size);\n    var correlationId = resp.readUInt32BE(4);\n\n    this.invokeResponseCallback(socket, correlationId, resp);\n    buffer.consume(size);\n  } else {\n    return;\n  }\n\n  if (socket.buffer.length) {\n    setImmediate(\n      function () {\n        this.handleReceivedData(socket);\n      }.bind(this)\n    );\n  }\n};\n\nClient.prototype.invokeResponseCallback = function (socket, correlationId, resp) {\n  var handlers = this.unqueueCallback(socket, correlationId);\n\n  if (handlers) {\n    var [decoder, cb] = handlers;\n    var result = decoder(resp);\n    if (result instanceof Error) {\n      cb.call(this, result);\n    } else {\n      cb.call(this, null, result);\n    }\n  } else {\n    logger.error(`missing handlers for Correlation ID: ${correlationId}`);\n  }\n};\n\nClient.prototype.queueCallback = function (socket, id, data) {\n  var socketId = socket.socketId;\n  var queue = this.cbqueue.get(socketId);\n  if (!queue) {\n    queue = new Map();\n    this.cbqueue.set(socketId, queue);\n  }\n\n  queue.set(id, data);\n};\n\nClient.prototype.unqueueCallback = function (socket, id) {\n  var socketId = socket.socketId;\n\n  var queue = this.cbqueue.get(socketId);\n  try {\n    if (!queue) {\n      return null;\n    }\n\n    if (!queue.has(id)) {\n      return null;\n    }\n\n    var result = queue.get(id);\n\n    // cleanup socket queue\n    queue.delete(id);\n\n    return result;\n  } finally {\n    if (queue && !queue.size) {\n      this.cbqueue.delete(socketId);\n    }\n  }\n};\n\nClient.prototype.clearCallbackQueue = function (socket, error) {\n  var socketId = socket.socketId;\n  var longpolling = socket.longpolling;\n\n  var queue = this.cbqueue.get(socketId);\n  if (!queue) {\n    return;\n  }\n\n  if (!longpolling) {\n    queue.forEach(function (handlers) {\n      var cb = handlers[1];\n      cb(error);\n    });\n  }\n\n  this.cbqueue.delete(socketId);\n};\n\nmodule.exports = Client;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}