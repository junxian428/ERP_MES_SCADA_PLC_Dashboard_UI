{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/web.immediate.js\");\nvar util = require('util');\nvar _ = require('lodash');\nvar Readable = require('stream').Readable;\nvar logger = require('./logging')('kafka-node:ConsumerStream');\nconst Denque = require('denque');\nvar CommitStream = require('./commitStream');\nvar protocol = require('./protocol');\nvar DEFAULTS = {\n  groupId: 'kafka-node-group',\n  // Auto commit config\n  autoCommit: true,\n  autoCommitMsgCount: 100,\n  autoCommitIntervalMs: 5000,\n  // Fetch message config\n  fetchMaxWaitMs: 100,\n  fetchMinBytes: 1,\n  fetchMaxBytes: 1024 * 1024,\n  bufferRefetchThreshold: 10,\n  fromOffset: false,\n  encoding: 'utf8'\n};\nvar ConsumerStream = function (client, topics, options) {\n  options.objectMode = true;\n  this.highWaterMark = options.highWaterMark = options.highWaterMark || 100;\n  Readable.call(this, options);\n  if (_.isEmpty(topics)) {\n    throw new Error('You must specify topics to subscribe to.');\n  }\n  // Whether we have sent a fetch request for which we have not yet received\n  // all messages.\n  this.fetchInFlight = false;\n  this.fetchCount = 0;\n  this.client = client;\n  this.options = _.defaults(options || {}, DEFAULTS);\n  this.ready = false;\n  this.payloads = this.buildPayloads(topics);\n  this.connect();\n  this.encoding = this.options.encoding;\n  this.emittedMessages = 0;\n  this.messageBuffer = new Denque();\n  this._reading = false;\n  this.close = this.close.bind(this);\n};\nutil.inherits(ConsumerStream, Readable);\n\n// The older non-stream based consumer emitted `message` events rather\n// than data events. This provides a backward compatibility layer for\n// receiving message events instead.\nConsumerStream.prototype._emit = ConsumerStream.prototype.emit;\nConsumerStream.prototype.emit = function () {\n  if (arguments[0] === 'data') {\n    this._emit('message', arguments[1]);\n  }\n  this._emit.apply(this, arguments);\n};\n\n/**\n * Implements the abstract Readable::_read() method.\n */\nConsumerStream.prototype._read = function () {\n  this._reading = true;\n  this.transmitMessages();\n};\n\n/**\n * Buffers the received message then checks to see if we should send.\n *\n * Messages are fetched from Kafka with a size limit and not a message\n * count while node.js object streams have a limit in object count. As\n * a result we maintain an internal buffer (this.messageBuffer) from\n * which we push messages onto the stream as appropriate in\n * this.transmitMessages().\n *\n * @param {Object} message - An Kafka message object.\n */\nConsumerStream.prototype.handleMessage = function (message) {\n  this.messageBuffer.push(message);\n  this.transmitMessages();\n};\nConsumerStream.prototype.transmitMessages = function () {\n  while (this._reading && !this.messageBuffer.isEmpty()) {\n    this._reading = this.push(this.messageBuffer.shift());\n  }\n  if (this.messageBuffer.isEmpty() && this._reading) {\n    this.fetch();\n  }\n};\n\n/**\n * Fetch messages from kafka if appropriate.\n */\nConsumerStream.prototype.fetch = function () {\n  var self = this;\n  if (self.ready && !self.fetchInFlight) {\n    self.fetchInFlight = true;\n    var encoder = protocol.encodeFetchRequest(self.fetchMaxWaitMs, self.fetchMinBytes);\n    var decoder = protocol.decodeFetchResponse(self.decodeCallback.bind(self), self.maxTickMessages);\n    self.client.send(self.payloads, encoder, decoder, function (err) {\n      if (err) {\n        Array.prototype.unshift.call(arguments, 'error');\n        self.emit.apply(self, arguments);\n      }\n      // If the buffer is below the configured threshold attempt a fetch.\n      if (self.messageBuffer.length < self.options.bufferRefetchThreshold) {\n        setImmediate(function () {\n          self.fetch();\n        });\n      }\n    });\n  }\n};\n\n/**\n * The decode callback is invoked as data is decoded from the response.\n */\nConsumerStream.prototype.decodeCallback = function (err, type, message) {\n  if (err) {\n    switch (err.message) {\n      case 'OffsetOutOfRange':\n        return this.emit('offsetOutOfRange', err);\n      case 'NotLeaderForPartition':\n        return this.emit('brokersChanged');\n      default:\n        return this.emit('error', err);\n    }\n  }\n  var encoding = this.options.encoding;\n  if (type === 'message') {\n    if (encoding !== 'buffer' && message.value) {\n      message.value = message.value.toString(encoding);\n    }\n    this.handleMessage(message);\n  } else if (type === 'done') {\n    // If we had neither error nor message, this is the end of a fetch,\n    // and we should update the offset for the next fetch.\n    this.updateOffsets(message);\n    this.fetchInFlight = false;\n  }\n};\nConsumerStream.prototype.connect = function () {\n  var self = this;\n\n  // Client already exists\n  if (this.client.ready) {\n    this.init();\n  }\n  this.client.on('ready', function () {\n    logger.debug('consumer ready');\n    if (!self.ready) self.init();\n  });\n  this.client.on('error', function (err) {\n    logger.debug('client error %s', err.message);\n    self.emit('error', err);\n  });\n  this.client.on('close', function () {\n    logger.debug('connection closed');\n  });\n  this.client.on('brokersChanged', function () {\n    var topicNames = self.payloads.map(function (p) {\n      return p.topic;\n    });\n    this.refreshMetadata(topicNames, function (err) {\n      if (err) return self.emit('error', err);\n    });\n  });\n};\nConsumerStream.prototype.updateOffsets = function (topics, initing) {\n  this.payloads.forEach(function (p) {\n    if (!_.isEmpty(topics[p.topic]) && topics[p.topic][p.partition] !== undefined) {\n      var offset = topics[p.topic][p.partition];\n      // Note, we track the offset of the next message we want to see,\n      // not the most recent message we have seen.\n      if (offset === -1) offset = 0;\n      if (!initing) p.offset = offset + 1;else p.offset = offset;\n    }\n  });\n};\nConsumerStream.prototype.close = function (force, cb) {\n  if (typeof force === 'function') {\n    cb = force;\n    force = false;\n  }\n  let self = this;\n  if (force) {\n    self.commit(function (err) {\n      self.emit('error', err);\n      self.client.close(cb);\n    });\n  } else {\n    self.client.close(cb);\n  }\n  this.ready = false;\n};\nConsumerStream.prototype.init = function () {\n  if (!this.payloads.length) {\n    return;\n  }\n  var self = this;\n  var topics = self.payloads.map(function (p) {\n    return p.topic;\n  });\n  self.client.topicExists(topics, function (err) {\n    if (err) {\n      return self.emit('error', err);\n    }\n    var start = function () {\n      self.emit('readable');\n      self.ready = true;\n\n      // If this consumer was piped immediately then read may have been called\n      // before readable was emitted so we should trigger a fetch.\n      if (self._reading) {\n        setImmediate(function () {\n          self.fetch();\n        });\n      }\n    };\n    if (self.options.fromOffset) {\n      return start();\n    }\n    self.client.sendOffsetFetchRequest(self.options.groupId, self.payloads, function (err, topics) {\n      if (err) {\n        return self.emit('error', err);\n      }\n      self.updateOffsets(topics, true);\n      start();\n    });\n  });\n};\nConsumerStream.prototype.buildPayloads = function (payloads) {\n  var self = this;\n  return payloads.map(function (p) {\n    if (typeof p !== 'object') p = {\n      topic: p\n    };\n    p.partition = p.partition || 0;\n    p.offset = p.offset || 0;\n    p.maxBytes = self.options.fetchMaxBytes;\n    p.metadata = 'm'; // metadata can be arbitrary\n    return p;\n  });\n};\nConsumerStream.prototype.createCommitStream = function (options) {\n  options = options || this.options;\n  options = _.defaults(options || {}, this.options);\n  return new CommitStream(this.client, this.payloads, this.options.groupId, options);\n};\nmodule.exports = ConsumerStream;","map":{"version":3,"names":["require","util","_","Readable","logger","Denque","CommitStream","protocol","DEFAULTS","groupId","autoCommit","autoCommitMsgCount","autoCommitIntervalMs","fetchMaxWaitMs","fetchMinBytes","fetchMaxBytes","bufferRefetchThreshold","fromOffset","encoding","ConsumerStream","client","topics","options","objectMode","highWaterMark","call","isEmpty","Error","fetchInFlight","fetchCount","defaults","ready","payloads","buildPayloads","connect","emittedMessages","messageBuffer","_reading","close","bind","inherits","prototype","_emit","emit","arguments","apply","_read","transmitMessages","handleMessage","message","push","shift","fetch","self","encoder","encodeFetchRequest","decoder","decodeFetchResponse","decodeCallback","maxTickMessages","send","err","Array","unshift","length","setImmediate","type","value","toString","updateOffsets","init","on","debug","topicNames","map","p","topic","refreshMetadata","initing","forEach","partition","undefined","offset","force","cb","commit","topicExists","start","sendOffsetFetchRequest","maxBytes","metadata","createCommitStream","module","exports"],"sources":["D:/Project/VUEJSSPRING_CRUD_JWT/vue-crud-api-jwt-vuex/node_modules/kafka-node/lib/consumerStream.js"],"sourcesContent":["'use strict';\nvar util = require('util');\nvar _ = require('lodash');\nvar Readable = require('stream').Readable;\nvar logger = require('./logging')('kafka-node:ConsumerStream');\nconst Denque = require('denque');\nvar CommitStream = require('./commitStream');\n\nvar protocol = require('./protocol');\n\nvar DEFAULTS = {\n  groupId: 'kafka-node-group',\n  // Auto commit config\n  autoCommit: true,\n  autoCommitMsgCount: 100,\n  autoCommitIntervalMs: 5000,\n  // Fetch message config\n  fetchMaxWaitMs: 100,\n  fetchMinBytes: 1,\n  fetchMaxBytes: 1024 * 1024,\n  bufferRefetchThreshold: 10,\n  fromOffset: false,\n  encoding: 'utf8'\n};\n\nvar ConsumerStream = function (client, topics, options) {\n  options.objectMode = true;\n  this.highWaterMark = options.highWaterMark = options.highWaterMark || 100;\n  Readable.call(this, options);\n  if (_.isEmpty(topics)) {\n    throw new Error('You must specify topics to subscribe to.');\n  }\n  // Whether we have sent a fetch request for which we have not yet received\n  // all messages.\n  this.fetchInFlight = false;\n  this.fetchCount = 0;\n  this.client = client;\n  this.options = _.defaults(options || {}, DEFAULTS);\n  this.ready = false;\n  this.payloads = this.buildPayloads(topics);\n  this.connect();\n  this.encoding = this.options.encoding;\n  this.emittedMessages = 0;\n  this.messageBuffer = new Denque();\n  this._reading = false;\n  this.close = this.close.bind(this);\n};\nutil.inherits(ConsumerStream, Readable);\n\n// The older non-stream based consumer emitted `message` events rather\n// than data events. This provides a backward compatibility layer for\n// receiving message events instead.\nConsumerStream.prototype._emit = ConsumerStream.prototype.emit;\nConsumerStream.prototype.emit = function () {\n  if (arguments[0] === 'data') {\n    this._emit('message', arguments[1]);\n  }\n  this._emit.apply(this, arguments);\n};\n\n/**\n * Implements the abstract Readable::_read() method.\n */\nConsumerStream.prototype._read = function () {\n  this._reading = true;\n  this.transmitMessages();\n};\n\n/**\n * Buffers the received message then checks to see if we should send.\n *\n * Messages are fetched from Kafka with a size limit and not a message\n * count while node.js object streams have a limit in object count. As\n * a result we maintain an internal buffer (this.messageBuffer) from\n * which we push messages onto the stream as appropriate in\n * this.transmitMessages().\n *\n * @param {Object} message - An Kafka message object.\n */\nConsumerStream.prototype.handleMessage = function (message) {\n  this.messageBuffer.push(message);\n  this.transmitMessages();\n};\n\nConsumerStream.prototype.transmitMessages = function () {\n  while (this._reading && !this.messageBuffer.isEmpty()) {\n    this._reading = this.push(this.messageBuffer.shift());\n  }\n  if (this.messageBuffer.isEmpty() && this._reading) {\n    this.fetch();\n  }\n};\n\n/**\n * Fetch messages from kafka if appropriate.\n */\nConsumerStream.prototype.fetch = function () {\n  var self = this;\n  if (self.ready && !self.fetchInFlight) {\n    self.fetchInFlight = true;\n    var encoder = protocol.encodeFetchRequest(self.fetchMaxWaitMs, self.fetchMinBytes);\n    var decoder = protocol.decodeFetchResponse(self.decodeCallback.bind(self), self.maxTickMessages);\n    self.client.send(self.payloads, encoder, decoder, function (err) {\n      if (err) {\n        Array.prototype.unshift.call(arguments, 'error');\n        self.emit.apply(self, arguments);\n      }\n      // If the buffer is below the configured threshold attempt a fetch.\n      if (self.messageBuffer.length < self.options.bufferRefetchThreshold) {\n        setImmediate(function () {\n          self.fetch();\n        });\n      }\n    });\n  }\n};\n\n/**\n * The decode callback is invoked as data is decoded from the response.\n */\nConsumerStream.prototype.decodeCallback = function (err, type, message) {\n  if (err) {\n    switch (err.message) {\n      case 'OffsetOutOfRange':\n        return this.emit('offsetOutOfRange', err);\n      case 'NotLeaderForPartition':\n        return this.emit('brokersChanged');\n      default:\n        return this.emit('error', err);\n    }\n  }\n\n  var encoding = this.options.encoding;\n\n  if (type === 'message') {\n    if (encoding !== 'buffer' && message.value) {\n      message.value = message.value.toString(encoding);\n    }\n    this.handleMessage(message);\n  } else if (type === 'done') {\n    // If we had neither error nor message, this is the end of a fetch,\n    // and we should update the offset for the next fetch.\n    this.updateOffsets(message);\n    this.fetchInFlight = false;\n  }\n};\n\nConsumerStream.prototype.connect = function () {\n  var self = this;\n\n  // Client already exists\n  if (this.client.ready) {\n    this.init();\n  }\n\n  this.client.on('ready', function () {\n    logger.debug('consumer ready');\n    if (!self.ready) self.init();\n  });\n\n  this.client.on('error', function (err) {\n    logger.debug('client error %s', err.message);\n    self.emit('error', err);\n  });\n\n  this.client.on('close', function () {\n    logger.debug('connection closed');\n  });\n\n  this.client.on('brokersChanged', function () {\n    var topicNames = self.payloads.map(function (p) {\n      return p.topic;\n    });\n\n    this.refreshMetadata(topicNames, function (err) {\n      if (err) return self.emit('error', err);\n    });\n  });\n};\n\nConsumerStream.prototype.updateOffsets = function (topics, initing) {\n  this.payloads.forEach(function (p) {\n    if (!_.isEmpty(topics[p.topic]) && topics[p.topic][p.partition] !== undefined) {\n      var offset = topics[p.topic][p.partition];\n      // Note, we track the offset of the next message we want to see,\n      // not the most recent message we have seen.\n      if (offset === -1) offset = 0;\n      if (!initing) p.offset = offset + 1;\n      else p.offset = offset;\n    }\n  });\n};\n\nConsumerStream.prototype.close = function (force, cb) {\n  if (typeof force === 'function') {\n    cb = force;\n    force = false;\n  }\n  let self = this;\n\n  if (force) {\n    self.commit(function (err) {\n      self.emit('error', err);\n      self.client.close(cb);\n    });\n  } else {\n    self.client.close(cb);\n  }\n  this.ready = false;\n};\n\nConsumerStream.prototype.init = function () {\n  if (!this.payloads.length) {\n    return;\n  }\n\n  var self = this;\n  var topics = self.payloads.map(function (p) {\n    return p.topic;\n  });\n\n  self.client.topicExists(topics, function (err) {\n    if (err) {\n      return self.emit('error', err);\n    }\n\n    var start = function () {\n      self.emit('readable');\n      self.ready = true;\n\n      // If this consumer was piped immediately then read may have been called\n      // before readable was emitted so we should trigger a fetch.\n      if (self._reading) {\n        setImmediate(function () {\n          self.fetch();\n        });\n      }\n    };\n\n    if (self.options.fromOffset) {\n      return start();\n    }\n\n    self.client.sendOffsetFetchRequest(self.options.groupId, self.payloads, function (err, topics) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      self.updateOffsets(topics, true);\n      start();\n    });\n  });\n};\n\nConsumerStream.prototype.buildPayloads = function (payloads) {\n  var self = this;\n  return payloads.map(function (p) {\n    if (typeof p !== 'object') p = { topic: p };\n    p.partition = p.partition || 0;\n    p.offset = p.offset || 0;\n    p.maxBytes = self.options.fetchMaxBytes;\n    p.metadata = 'm'; // metadata can be arbitrary\n    return p;\n  });\n};\n\nConsumerStream.prototype.createCommitStream = function (options) {\n  options = options || this.options;\n  options = _.defaults(options || {}, this.options);\n  return new CommitStream(this.client, this.payloads, this.options.groupId, options);\n};\n\nmodule.exports = ConsumerStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}